<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Robin Denz and Nina Timmesfeld" />


<title>Simulating Complex Crossectional and Longitudinal Data using the simDAG R Package</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>

<style type="text/css">
p.abstract{
text-align: center;
font-weight: bold;
}
div.abstract{
margin: auto;
width: 90%;
}
</style>


<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Simulating Complex Crossectional and
Longitudinal Data using the simDAG R Package</h1>
<h4 class="author">Robin Denz and Nina Timmesfeld</h4>
<div class="abstract">
<p class="abstract">Abstract</p>
This introduction to the <code>simDAG</code> <code>R</code> Package is a
(slightly) modified version of a provisionally accepted article in the
<em>Journal of Statistical Software</em>. If you use this package or
want to cite information contained in this article, please cite the
arXiv version <span class="citation">(Denz and Timmesfeld 2025)</span>.
<br><br> Generating artificial data is a crucial step when performing
Monte-Carlo simulation studies. Depending on the planned study, complex
data generation processes (DGP) containing multiple, possibly
time-varying, variables with various forms of dependencies and data
types may be required. Simulating data from such DGP may therefore
become a difficult and time-consuming endeavor. The <code>simDAG</code>
<code>R</code> package offers a standardized approach to generate data
from simple and complex DGP based on the definition of structural
equations in directed acyclic graphs using arbitrary functions or
regression models. The package offers a clear syntax with an enhanced
formula interface and directly supports generating binary, categorical,
count and time-to-event data with arbitrary dependencies, possibly
non-linear relationships and interactions. It additionally includes a
framework to conduct discrete-time based simulations which allows the
generation of longitudinal data on a semi-continuous time-scale. This
approach may be used to generate time-to-event data with both recurrent
or competing events and possibly multiple time-varying covariates, which
may themselves have arbitrary data types. In this article we demonstrate
the vast amount of features included in <code>simDAG</code> by
replicating the DGP of multiple real Monte-Carlo simulation studies.
<br><br>
</div>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#using-dags-to-define-data-generation-processes" id="toc-using-dags-to-define-data-generation-processes">Using DAGs to
define data generation processes</a></li>
<li><a href="#comparison-with-existing-software" id="toc-comparison-with-existing-software">Comparison with existing
software</a></li>
<li><a href="#organization-of-this-article" id="toc-organization-of-this-article">Organization of this
article</a></li>
</ul></li>
<li><a href="#the-workflow" id="toc-the-workflow">The workflow</a>
<ul>
<li><a href="#included-functions" id="toc-included-functions">Included
functions</a></li>
<li><a href="#defining-the-dag" id="toc-defining-the-dag">Defining the
DAG</a></li>
<li><a href="#supported-node-types" id="toc-supported-node-types">Supported node types</a></li>
</ul></li>
<li><a href="#simulating-crossectional-data" id="toc-simulating-crossectional-data">Simulating crossectional
data</a></li>
<li><a href="#simulating-longitudinal-data-with-few-points-in-time" id="toc-simulating-longitudinal-data-with-few-points-in-time">Simulating
longitudinal data with few points in time</a></li>
<li><a href="#simulating-longitudinal-data-with-many-points-in-time" id="toc-simulating-longitudinal-data-with-many-points-in-time">Simulating
longitudinal data with many points in time</a>
<ul>
<li><a href="#formal-description" id="toc-formal-description">Formal
description</a></li>
<li><a href="#a-simple-example" id="toc-a-simple-example">A simple
example</a></li>
<li><a href="#simulating-adverse-events-after-covid-19-vaccination" id="toc-simulating-adverse-events-after-covid-19-vaccination">Simulating
adverse events after Covid-19 vaccination</a></li>
<li><a href="#additionally-supported-features" id="toc-additionally-supported-features">Additionally supported
features</a></li>
<li><a href="#computational-considerations" id="toc-computational-considerations">Computational
considerations</a></li>
</ul></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
<li><a href="#computational-details" id="toc-computational-details">Computational details</a></li>
<li><a href="#acknowledgments" id="toc-acknowledgments">Acknowledgments</a></li>
<li><a href="#appendix-a-further-features-of-discrete-time-simulation" id="toc-appendix-a-further-features-of-discrete-time-simulation">Appendix
A: Further Features of Discrete-Time Simulation</a>
<ul>
<li><a href="#time-dependent-base-probabilities" id="toc-time-dependent-base-probabilities">Time-Dependent Base
Probabilities</a></li>
<li><a href="#time-dependent-effects" id="toc-time-dependent-effects">Time-Dependent Effects</a></li>
<li><a href="#non-linear-effects" id="toc-non-linear-effects">Non-Linear
Effects</a></li>
<li><a href="#multiple-interrelated-binary-time-dependent-variables" id="toc-multiple-interrelated-binary-time-dependent-variables">Multiple
Interrelated Binary Time-Dependent Variables</a></li>
<li><a href="#using-baseline-covariates" id="toc-using-baseline-covariates">Using Baseline Covariates</a></li>
<li><a href="#using-categorical-time-dependent-variables" id="toc-using-categorical-time-dependent-variables">Using Categorical
Time-Dependent Variables</a></li>
<li><a href="#using-continuous-time-dependent-variables" id="toc-using-continuous-time-dependent-variables">Using Continuous
Time-Dependent Variables</a></li>
<li><a href="#ordered-events" id="toc-ordered-events">Ordered
Events</a></li>
</ul></li>
<li><a href="#literature" id="toc-literature">Literature</a></li>
</ul>
</div>

<div id="introduction" class="section level1">
<h1>Introduction</h1>
<div id="motivation" class="section level2">
<h2>Motivation</h2>
<p>Applied researchers and statisticians frequently use Monte-Carlo
simulation techniques in a variety of ways. They are used to estimate
required sample sizes <span class="citation">(Arnold et al.
2011)</span>, formally compare different statistical methods <span class="citation">(Morris, White, and Crowther 2019; Denz,
Klaaßen-Mielke, and Timmesfeld 2023)</span>, help design and plan
clinical trials <span class="citation">(Kimko and Duffull 2002; Nance et
al. 2024)</span> or for teaching purposes <span class="citation">(Sigal
and Chalmers 2016; Fox et al. 2022)</span>. The main reason for their
broad usage is that the researcher has full control over the true data
generation process (DGP). In general, the researcher will define a DGP
appropriate to the situation and generate multiple datasets from it.
Some statistical analysis technique is then applied to each dataset and
the results are analyzed. A crucial step in every kind of Monte-Carlo
simulation study is thus the generation of these datasets.</p>
<p>Depending on the DGP that is required by the researcher, this step
may become very difficult and time consuming. For example, some
Monte-Carlo simulations require the generation of complex longitudinal
data with variables of different types that are causally related in
various ways <span class="citation">(Asparouhov and Muthén 2020)</span>.
Some of these possible data types are continuous variables, categorical
variables, count variables or time-to-event variables. All of these
require different parametrizations and simulation strategies. If
interactions or non-linear relationships between these variables are
required, simulating data from the DGP becomes even more
challenging.</p>
<p>Generating any artificial data requires (1) a formal description of
the DGP, (2) the knowledge of an algorithm that may be used to generate
the data from this DGP, and (3) the ability to create a software
application to implement that algorithm. Although many statisticians may
have no problem with theses steps, this might not be the case for more
applied researchers. More importantly, the third step in particular may
require a high level of expertise in programming, because the resulting
program has to be validated extensively while it also has to be
computationally efficient enough to allow potentially thousands of
datasets to be generated in a reasonable amount of time. Additionally,
it also has to be flexible enough to allow the user to easily make
changes to the DGP to be useful in most cases <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span>. A
comprehensive software application that automates most of the required
work would therefore be of great benefit to the scientific
community.</p>
<p>In this article we present the <code>simDAG</code> <code>R</code>
package, which offers an easy to use and consistent framework to
generate arbitrarily complex crossectional and longitudinal data. The
aim of the package is to make all three steps of the data generation
process easier by giving users a standardized way to define the desired
DGP, which can then be used directly to generate the data without
further user input. It does so by requiring the user to define a
directed acyclic graph (DAG) with additional information about the
associations between the supplied variables <span class="citation">(Pearl 2009)</span>. The package was created using the
<code>R</code> programming language <span class="citation">(R Core Team
2024)</span> and is available on the Comprehensive <code>R</code>
Archive Network (CRAN) at <a href="https://cran.r-project.org/package=simDAG" class="uri">https://cran.r-project.org/package=simDAG</a>.</p>
</div>
<div id="using-dags-to-define-data-generation-processes" class="section level2">
<h2>Using DAGs to define data generation processes</h2>
<p>In this package, the user is required to describe the desired DGP as
a causal DAG. Formally, a DAG is a mathematical graph consisting of a
set of <span class="math inline">\(V\)</span> nodes (or vertices) and a
set of <span class="math inline">\(E\)</span> edges (or links)
connecting pairs of nodes. As its’ name suggests, a DAG consists only of
<em>directed</em> edges and is <em>acyclic</em>, meaning that there are
no cycles when following directed paths on the DAG <span class="citation">(Byeon and Lee 2023)</span>. A causal DAG is a special
sort of DAG in which the nodes represent random variables and the edges
represent directed causal relationships between these variables <span class="citation">(Pearl 2009)</span>. A very simple example containing
only three nodes and no time-dependencies is given in Figure 1. The DAG
in this figure contains a directed arrow from <span class="math inline">\(A\)</span> to <span class="math inline">\(C\)</span> and from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>. This translates to the assumptions
that there is a direct causal effect of <span class="math inline">\(A\)</span> on <span class="math inline">\(C\)</span> and of <span class="math inline">\(B\)</span> on <span class="math inline">\(C\)</span>, but no direct causal relationship
between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> (due to the absence of an arrow between
them).</p>
<div class="figure" style="text-align: center">
<img src="data:image/png;base64,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" alt="An example DAG with three nodes." width="300" />
<p class="caption">
An example DAG with three nodes.
</p>
</div>
<p>Such DAGs are the cornerstone of the <em>structural approach</em> to
causal inference developed by <span class="citation">Pearl (2009)</span>
and <span class="citation">Spirtes, Glymour, and Scheines (2000)</span>.
They are used extensively in social research <span class="citation">(Wouk, Bauer, and Gottfredson 2019)</span>, economics
<span class="citation">(Imbens 2020)</span> and epidemiology <span class="citation">(Byeon and Lee 2023)</span> to encode causal
assumptions about the real underlying DGP of empirical data. For
empirical research such graphs are very useful because they give a clear
overview of the causal assumptions made by the researchers. By using
causal graphical methods such as the <em>backdoor</em> criterion <span class="citation">(Pearl 2009)</span> or the <em>frontdoor</em> criterion
<span class="citation">(Pearl 1995)</span>, it is also possible to use
such graphs to determine which variables need to be adjusted for in
order to get unbiased estimates of certain causal effects. The
<code>daggitty</code> <code>R</code> package directly implements
multiple tools for this kind of usage <span class="citation">(Textor et
al. 2016)</span>.</p>
<p>These kind of DAGs can be formally described using <em>structural
equations</em>. These equations describe how each node is distributed.
For example, a general set of structural equations that may be used to
describe the DAG in Figure 1 are:</p>
<p><span class="math display">\[
    \begin{aligned}
        A \sim &amp; f_A(U_A), \\
        B \sim &amp; f_B(U_B), \\
        C \sim &amp; f_C(A, B, U_C). \\
    \end{aligned}
\]</span></p>
<p>In these equations, the unspecified functions <span class="math inline">\(f_A\)</span>, <span class="math inline">\(f_B\)</span> and <span class="math inline">\(f_C\)</span> describe how exactly the nodes are
distributed, possibly conditional on other nodes. The terms <span class="math inline">\(U_A\)</span>, <span class="math inline">\(U_B\)</span> and <span class="math inline">\(U_C\)</span> denote random errors or disturbances.
If the functions in these structural equations are not specified and
some assumption on the probability distribution of the error terms is
made, this is equivalent to a non-parametric structural equation model
<span class="citation">(Pearl 2009; Sofrygin, van der Laan, and
Neugebauer 2017)</span>.</p>
<p>To make the generation of data from a DAG possible, however, it is
not enough to only specify which variables are causally related to one
another. The structural equations now also have to be fully specified.
This means that the distribution functions of each node will have to be
defined in some way by the user. A popular way to do this is to use
regression models and parametric distributions <span class="citation">(Kline 2023)</span>, but in theory any kind of function
may be used, allowing the definition of arbitrarily complex DGPs.
Continuing the example from above, we could define the structural
equations of the DAG as follows:</p>
<p><span class="math display">\[
    \begin{aligned}
        A \sim &amp; N(0, 1), \\
        B \sim &amp; N(0, 1), \\
        C \sim &amp; -2 + A\cdot0.3 + B\cdot-2 + N(0, 1). \\
    \end{aligned}
\]</span></p>
<p>This means that both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are independent standard normally
distributed variables and that <span class="math inline">\(C\)</span>
follows a simple linear regression model based on <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> with an independent normally
distributed error term with mean zero. Once all structural equations and
distribution functions have been defined, data may be generated from the
DAG using a fairly simple algorithm. This algorithm essentially
generates data for one node at a time, using only the supplied
definitions and the data generated in previous steps. This step-wise
method relies on the fact that every DAG can be <em>topologically
sorted</em>, which means that there is always an ordering of the nodes
such that for every link <span class="math inline">\((u_i, u_j)\)</span>
between nodes <span class="math inline">\(u_i\)</span> and <span class="math inline">\(u_j\)</span>, <span class="math inline">\(u_i\)</span> comes before <span class="math inline">\(u_j\)</span> <span class="citation">(Kahn
1962)</span>.</p>
<p>The generation of the data starts by ordering the nodes of the graph
in such a topologically sorted way. This means that nodes in the DAG
that have no arrows pointing into them, sometimes called <em>root
nodes</em>, are processed first. Data for these kinds of nodes can be
generated by sampling from a pre-specified parametric distribution, such
as a Gaussian distribution or a beta distribution, or through any other
process, such as re-sampling based strategies <span class="citation">(Carsey and Harden 2014)</span>. Once data for these
nodes has been generated, the data for the next node in the topological
order will be generated, based on the already generated data. These
nodes are called <em>child nodes</em>, because they are dependent on
other nodes, which are called their <em>parent nodes</em> <span class="citation">(Byeon and Lee 2023)</span>. For the example DAG shown
earlier, the two possible topological sortings are:</p>
<p><span class="math display">\[
    (A, B, C) \quad \text{and} \quad (B, A, C).
\]</span></p>
<p>Here, both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are root nodes because they do not have
any parents and <span class="math inline">\(C\)</span> is a child node
of both of its’ parents <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. To generate data for this example
using the algorithm described above, one would first generate <span class="math inline">\(n\)</span> random draws from a standard normal
distribution for both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Next, one would calculate the linear
combination of these values as specified by the linear regression model
in the earlier Equation and add <span class="math inline">\(n\)</span>
random draws from another standard normal distribution to it (which
represents the error term). In <code>R</code>, this simple example could
be simulated using the following code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">43</span>)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>A <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">rnorm</span>(n)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>B <span class="ot">&lt;-</span> stats<span class="sc">::</span><span class="fu">rnorm</span>(n)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>C <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">2</span> <span class="sc">+</span> A<span class="sc">*</span><span class="fl">0.3</span> <span class="sc">+</span> B<span class="sc">*-</span><span class="dv">2</span> <span class="sc">+</span> stats<span class="sc">::</span><span class="fu">rnorm</span>(n)</span></code></pre></div>
<p>Although the manual code required for this example is fairly simple,
this is no longer the case in DAGs with more nodes and/or a more complex
DGP (for example one including different data types). The
<code>simDAG</code> package offers a standardized way to define any
possible DAG and the required distribution functions to facilitate a
clear and reproducible workflow.</p>
<p>The previous explanations and the given example focused on the simple
case of crossectional data without any time-dependencies. It is,
however, fairly straightforward to include a time-varying structure into
any DAG as well by simply adding a time-index to the time-varying nodes
and repeating the node for each point in time that should be considered
<span class="citation">(Hernán and Robins 2020)</span>. The proposed
package features computationally efficient functions to automate this
process for large amounts of time-points using a <em>discrete-time
simulation</em> approach <span class="citation">(Tang, Leu, and Abbass
2020)</span>. Although this procedure relies on a discrete time scale,
it can be used to generate data on a semi-continuous time-scale by using
very small steps in time. This is described in more detail in a later
Section.</p>
<p>Note also that while causal DAGs imply a specific causal structure,
the algorithms and code described here do not necessitate that this
causal structure has to be interpreted as such in the generated data.
For example, the structural equations shown earlier state that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are direct causes of <span class="math inline">\(C\)</span>, but the datasets that can be generated
from these equations could also be interpreted as <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> being only associated with <span class="math inline">\(C\)</span> for unknown reasons. As long as the
desired DGP can be <em>described</em> as a DAG, which is almost always
the case, this strategy may be used effectively to generate data even
for Monte-Carlo studies <em>not</em> concerned with causal
inference.</p>
<p>Although the data-generation algorithm described above is appropriate
for most applications, it may not be the best choice for validating
causal discovery methods, due to the marginal variance of each variable
increasing along the order of the topological sorting <span class="citation">(Reisach, Seiler, and Weichwald 2021)</span>. Other
methods, such as the onion method proposed by <span class="citation">Andrews and Kummerfeld (2024)</span> may be preferable
in this particular case.</p>
</div>
<div id="comparison-with-existing-software" class="section level2">
<h2>Comparison with existing software</h2>
<p>There are many different software packages that may be used to
generate data in the <code>R</code> programming language and other
languages such as <code>Python</code>. It is infeasible to summarise all
of them here, so we will only focus on a few that offer functionality
similar to the <code>simDAG</code> package instead. The following review
is therefore not intended to be exhaustive. We merely aim to show how
the existing software differs from the proposed package.</p>
<p>Multiple <code>R</code> packages support the generation of synthetic
data from fully specified structural equation models. The
<code>lavaan</code> package <span class="citation">(Rosseel
2012)</span>, the <code>semTools</code> package <span class="citation">(Jorgensen et al. 2022)</span> and the
<code>simsem</code> package <span class="citation">(Pornprasertmanit et
al. 2021)</span> are a few examples. However, these packages focus
solely on structural equation models with linear relationships and as
such do not allow the generation of data with different data types. For
example, none of these packages allow the generation of time-to-event
data, which is a type of data that is often needed in simulation
studies. Specialized <code>R</code> packages such as the
<code>survsim</code> <span class="citation">(Moriña and Navarro
2017)</span>, <code>simsurv</code> <span class="citation">(Brilleman et
al. 2021)</span>, <code>rsurv</code> <span class="citation">(Demarqui
2024)</span> and <code>reda</code> <span class="citation">(Wang et al.
2022)</span> packages may be used to simulate such data instead.
Although some of these packages allow generation of recurrent events,
competing events and general multi-state time-to-event data, unlike the
<code>simDAG</code> package, none of them support arbitrary mixtures of
these data types or time-varying covariates.</p>
<p>Other packages, such as the <code>simPop</code> package <span class="citation">(Templ et al. 2017)</span> and the
<code>simFrame</code> package <span class="citation">(Alfons, Templ, and
Filzmoser 2010)</span> allow generation of more complex synthetic data
structures as well, but are mostly focused on generating data that
mimicks real datasets. Similarly, the <code>simtrial</code> package
offers very flexible tools for the generation of randomized controlled
trial data, but it would be difficult to use it to generate other data
types. Software directly based on causal DAGs as DGPs also exists.
Although it is not stated in the package documentation directly, the
<code>simstudy</code> package <span class="citation">(Goldfeld and
Wujciak-Jens 2020)</span> also relies on the DAG based algorithm
described earlier. It supports the use of different data types and
custom generation functions, but only has partial support for generation
of longitudinal data. Alternatively, the <code>Python</code> library
<code>DagSim</code> <span class="citation">(Hajj, Pensar, and Sandve
2023)</span> allows users to generate arbitrary forms of data, while
also allowing the user to supply custom functions for the data
generation process. The price for this flexibility is, however, that not
many default options are implemented in the library.</p>
<p>Finally, the <code>simcausal</code> <code>R</code> package <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span> is
very similar to the <code>simDAG</code> package and was in fact a big
inspiration for it. Like the <code>simDAG</code> package, it is also
based on the causal DAG framework. The syntax for defining a DAG is
nearly the same, with some differences in how formula objects can and
should be specified. Unlike the proposed package, however, the
<code>simcausal</code> package is focused mostly on generating data for
simulation studies dealing with causal inference. As such, it also
directly supports the generation of data after performing some
interventions on the DAG <span class="citation">(Pearl 2009)</span>.
Although the proposed package lacks such functionality, it is a lot more
flexible in terms of what data can be generated. <code>simDAG</code>
supports the use of arbitrary data generation functions, the definition
of interactions, non-linear relationships and mixed model syntax in its’
formula interface and categorical input data for nodes. None of these
features are present in <code>simcausal</code> <span class="citation">(Sofrygin, van der Laan, and Neugebauer
2017)</span>.</p>
</div>
<div id="organization-of-this-article" class="section level2">
<h2>Organization of this article</h2>
<p>First, we will introduce the most important functionality of the
proposed package by describing the core functions and the usual workflow
when employing the package. This includes a detailed description of how
to translate the theoretical description of the desired DGP into a
<code>DAG</code> object, which may then be used to generate data.
Afterwards we will illustrate the capabilities of the package by
reproducing the DGPs of multiple real Monte-Carlo simulation studies.
Two DGPs describing the generation of crossectional data and
longitudinal data with only few considered points in time will be
considered first. Afterwards, an introduction into the generation of
more complex longitudinal data utilizing the discrete-time simulation
approach is presented. Finally, the package and its potential usefulness
is discussed.</p>
</div>
</div>
<div id="the-workflow" class="section level1">
<h1>The workflow</h1>
<div id="included-functions" class="section level2">
<h2>Included functions</h2>
<p>The following functions are used in a typical workflow using the
<code>simDAG</code> <code>R</code> package.</p>
<table>
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<tbody>
<tr class="odd">
<td><code>empty_dag()</code></td>
<td>Initializes an empty <code>DAG</code> object, which should be later
filled with information on relevant nodes. <code>DAG</code> objects are
the most important data structure of this package. How to define and use
them is illustrated in more detail below.</td>
</tr>
<tr class="even">
<td><code>node()</code> and <code>node_td()</code></td>
<td>Can be used to define one or multiple nodes each. These functions
are typically used to fill the <code>DAG</code> objects with information
about how the respective node should be generated, e.g., which other
nodes it depends on (if any), whether it is time-dependent or not, what
kind of data type it should be and the exact structural equation that it
should follow. <code>node()</code> can only be used to define nodes at
one specific point in time, while the <code>node_td()</code> function
should only be used to define time-varying nodes for discrete-time
simulations.</td>
</tr>
<tr class="odd">
<td><code>add_node()</code> or <code>DAG + node</code></td>
<td>Allows the definition made by <code>node()</code> or
<code>node_td()</code> to be added to the <code>DAG</code> object.</td>
</tr>
<tr class="even">
<td><code>plot.DAG()</code></td>
<td>Directly plots a <code>DAG</code> object using the
<code>ggplot2</code> library <span class="citation">(Wickham
2016)</span>.</td>
</tr>
<tr class="odd">
<td><code>summary.DAG()</code></td>
<td>May be used to print the underlying structural equations of all
nodes in a <code>DAG</code> object.</td>
</tr>
<tr class="even">
<td><code>sim_from_dag()</code></td>
<td>Is one of the two core simulation functions. Given a fully specified
<code>DAG</code> object that only includes nodes defined using
<code>node()</code>, it randomly generates a <code>data.table</code>
<span class="citation">(Barrett et al. 2024)</span> according to the DGP
specified by the <code>DAG</code>.</td>
</tr>
<tr class="odd">
<td><code>sim_discrete_time()</code></td>
<td>Is the second core simulation function. Given a fully specified
<code>DAG</code> object that includes one or multiple nodes added using
the <code>node_td()</code> function, and possibly one or multiple nodes
added using the <code>node()</code> function, it randomly generates data
according to the specified DGP using a discrete-time simulation
approach. This is described in detail in a later Section.</td>
</tr>
<tr class="even">
<td><code>sim_n_datasets()</code></td>
<td>Allows users to directly generate multiple datasets from a single
<code>DAG</code>, possibly using parallel processing.</td>
</tr>
<tr class="odd">
<td><code>sim2data()</code></td>
<td>May be used to transform the output produced by the
<code>sim_discrete_time()</code> function into either the <em>wide</em>,
<em>long</em> or <em>start-stop</em> format to make further usage of the
generated data easier.</td>
</tr>
</tbody>
</table>
<p>The package additionally includes multiple functions starting with
<code>node_</code>. These functions are used to generate data of
different types and using different specifications. Usually they do not
have to be called directly by the user. Instead they are specified as
<code>type</code>s in the <code>node()</code> or <code>node_td()</code>
functions and only called internally. Some additional convenience
functions are also included, but are not further discussed in this
article. Instead we choose to focus on describing the core functionality
in detail and refer the interested user to the official documentation
for more information.</p>
</div>
<div id="defining-the-dag" class="section level2">
<h2>Defining the DAG</h2>
<p>Regardless of which kind of data the user want to generate, it is
always necessary to first define a <code>DAG</code> object which
adequately describes the DGP the user wants to simulate. In most cases
this should be done using the following steps:</p>
<ul>
<li><strong>(1)</strong> Initialize an empty <code>DAG</code> object
using the <code>empty_dag()</code> function.</li>
<li><strong>(2)</strong> Define one or multiple nodes using the
<code>node()</code> or <code>node_td()</code> functions.</li>
<li><strong>(3)</strong> Add these nodes to the <code>DAG</code> using
the <code>+</code> syntax or the <code>add_node()</code> function.</li>
</ul>
<p>The <code>empty_dag()</code> function is very simple, as it does not
have any arguments. It is merely used to setup the initial
<code>DAG</code> object. The actual definition of the nodes should be
done using either the <code>node()</code> function (node at a single
point in time) or <code>node_td()</code> function (node that varies over
time), which have the following syntax:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">node</span>(name, type, <span class="at">parents=</span><span class="cn">NULL</span>, <span class="at">formula=</span><span class="cn">NULL</span>, ...)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="fu">node_td</span>(name, type, <span class="at">parents=</span><span class="cn">NULL</span>, <span class="at">formula=</span><span class="cn">NULL</span>, ...)</span></code></pre></div>
<p>The arguments are:</p>
<ul>
<li><code>name</code>: A character string of the name of the node that
should be generated, or a character vector including multiple names. If
a character vector with more than one name is supplied, multiple
independent nodes with the same definition will be added to the
<code>DAG</code> object.</li>
<li><code>type</code>: A character string specifying the type of the
node or any suitable function that can be used to generate data for a
node. Further details on supported node types are given in the next
Section.</li>
<li><code>parents</code>: If the node is a child node this argument
should contain the names of its’ parents, unless a <code>formula</code>
is supplied instead.</li>
<li><code>formula</code>: An optional formula object that specifies an
additive combination of coefficients and variables as required by
generalized linear models for example. This argument may be used for
most built-in node types and for user-defined functions. It allows
inclusion of internally generated dummy variables (when using
categorical variables as parents), interaction terms of arbitrarily high
orders, cubic terms and arbitrary mixed model syntax for some node
types.</li>
<li><code>...</code>: Additional arguments passed to the function
defined by the <code>type</code> argument.</li>
</ul>
<p>For example, the simple DAG that we described earlier may be created
using the following code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;simDAG&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="fu">node</span>(<span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="at">type=</span><span class="st">&quot;rnorm&quot;</span>, <span class="at">mean=</span><span class="dv">0</span>, <span class="at">sd=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;C&quot;</span>, <span class="at">type=</span><span class="st">&quot;gaussian&quot;</span>, <span class="at">formula=</span><span class="sc">~-</span><span class="dv">2</span> <span class="sc">+</span> A<span class="sc">*</span><span class="fl">0.3</span> <span class="sc">+</span> B<span class="sc">*-</span><span class="dv">2</span>,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>       <span class="at">error=</span><span class="dv">1</span>)</span></code></pre></div>
<p>First, an empty <code>DAG</code> object is initialized using the
<code>empty_dag()</code> function, to which nodes are added directly
using the <code>+</code> syntax. Here, only the <code>node()</code>
function is required, because all nodes only have to be defined for a
single point in time, since this DAG is only supposed to describe
crossectional data. Additionally, since both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> have the same structural equation here,
only one call to <code>node()</code> is needed to define both of these
nodes. By setting <code>type=&quot;rnorm&quot;</code> and leaving both the
<code>parents</code> and the <code>formula</code> arguments at their
default values, these nodes are specified as root nodes for which values
will be generated using the <code>rnorm()</code> function with the
additional arguments passed afterwards. Because <span class="math inline">\(C\)</span> is supposed to follow a linear
regression model, <code>type=&quot;gaussian&quot;</code> is used here and the
structural equation is specified using the <code>formula</code>
argument.</p>
<p>The result is a <code>DAG</code> object. To re-create Figure 1, users
may use the associated S3 <code>plot()</code> method, which internally
uses the <code>igraph</code> package <span class="citation">(Csárdi et
al. 2024)</span> to put the nodes into position and the
<code>ggplot2</code> package <span class="citation">(Wickham
2016)</span> and the <code>ggforce</code> <span class="citation">(Pedersen 2022)</span> for the actual plotting:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;igraph&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;ggplot2&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;ggforce&quot;</span>)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="fu">plot</span>(dag, <span class="at">layout=</span><span class="st">&quot;as_tree&quot;</span>, <span class="at">node_size=</span><span class="fl">0.15</span>, <span class="at">node_fill=</span><span class="st">&quot;grey&quot;</span>,</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>     <span class="at">node_text_fontface=</span><span class="st">&quot;italic&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The output is not exactly the same as Figure 1 because of space
reasons, but it is very similar. Additionally, the underlying structural
equations may be printed directly using the associated S3
<code>summary()</code> method:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">summary</span>(dag)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; A ~ N(0, 1)</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; B ~ N(0, 1)</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; C ~ N(-2 + A*0.3 + B*-2, 1)</span></span></code></pre></div>
<p>Both of these methods may be useful to check whether the DAG is
defined as intended by the user, or to formally describe the DGP in a
publication.</p>
</div>
<div id="supported-node-types" class="section level2">
<h2>Supported node types</h2>
<p>Different <code>type</code>s of nodes are supported, depending on
what kind of node is being specified. If the node is a root node, any
function with an argument called <code>n</code> that specifies how many
observations of some kind should be generated may be used. For example,
the base <code>R</code> <code>runif()</code> function may be used as a
type to generate a uniformly distributed node. Other popular choices are
<code>rnorm()</code> for normally distributed nodes or
<code>rgamma()</code> for a gamma distributed node. For convenience, the
proposed package also includes implementations for fast Bernoulli trials
(<code>rbernoulli()</code>), fast sampling from discrete probability
distributions (<code>rcategorical()</code>) and a function to set a node
to a constant value (<code>rconstant()</code>).</p>
<p>If the node has one or more parent nodes, any function that can
generate data based on these nodes and has the arguments
<code>data</code> (containing the data generated up to this point) and
<code>parents</code> (a vector with the names of the parent nodes) may
be used as <code>type</code>. Multiple popular choices are directly
implemented in this package. These include nodes based on generalized
linear models and potentially more complex functions to sample from
conditional distributions. Finally, the package also includes two
specialized functions which may only be used for discrete-time
simulations. These functions are able to generate binary or categorical
time-varying covariates, as well as multiple forms of time-to-event data
by repeatedly performing Bernoulli trials or multinomial trials over
time. More details are given in the Section on discrete-time simulation.
A brief overview over all implemented node types is given in the
following Table. Note that when using these node types, the user may
either pass the respective function directly to the <code>type</code>
argument, or use a string of the name without the <code>node_</code>
prefix.</p>
<table>
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead>
<tr class="header">
<th>Node type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>rbernoulli()</code></td>
<td>Samples from a Bernoulli distribution</td>
</tr>
<tr class="even">
<td><code>rcategorical()</code></td>
<td>Samples from a discrete probability distribution</td>
</tr>
<tr class="odd">
<td><code>rconstant()</code></td>
<td>Sets the node to a constant value</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>node_gaussian()</code></td>
<td>Generates a node based on a (mixed) linear regression model</td>
</tr>
<tr class="even">
<td><code>node_binomial()</code></td>
<td>Generates a node based on a (mixed) logistic regression model</td>
</tr>
<tr class="odd">
<td><code>node_conditional_prob()</code></td>
<td>Samples from a conditional discrete probability distribution</td>
</tr>
<tr class="even">
<td><code>node_conditional_distr()</code></td>
<td>Samples from different distributions conditional on values of other
variables</td>
</tr>
<tr class="odd">
<td><code>node_multinomial()</code></td>
<td>Generates a node based on a multinomial regression model</td>
</tr>
<tr class="even">
<td><code>node_poisson()</code></td>
<td>Generates a node based on a (mixed) Poisson regression model</td>
</tr>
<tr class="odd">
<td><code>node_negative_binomial()</code></td>
<td>Generates a node based on a negative binomial regression model</td>
</tr>
<tr class="even">
<td><code>node_zeroinfl()</code></td>
<td>Generates a node based on a zero-inflated Poisson or negative
binomial regression model</td>
</tr>
<tr class="odd">
<td><code>node_identity()</code></td>
<td>Generates a node based on an <code>R</code> expression that includes
previously generated nodes</td>
</tr>
<tr class="even">
<td><code>node_mixture()</code></td>
<td>Generates a node as a mixture of other node types</td>
</tr>
<tr class="odd">
<td><code>node_cox()</code></td>
<td>Generates a node based on a Cox proportional hazards regression
model, using the method of <span class="citation">Bender, Augustin, and
Blettner (2005)</span></td>
</tr>
<tr class="even">
<td><code>node_aftreg()</code>, <code>node_ahreg()</code>,
<code>node_ehreg()</code>, <code>node_poreg()</code>,
<code>node_ypreg()</code></td>
<td>Generates a node based on various parametric survival models as
implemented in <code>rsurv</code> <span class="citation">(Demarqui
2024)</span></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>node_time_to_event()</code></td>
<td>A node based on repeated Bernoulli trials over time, intended to
generate time-varying variables and time-to-event nodes</td>
</tr>
<tr class="odd">
<td><code>node_competing_events()</code></td>
<td>A node based on repeated multinomial trials over time, intended to
generate time-varying variables and time-to-event nodes</td>
</tr>
</tbody>
</table>
<p><strong>Table 1</strong>: A brief overview over all implemented node
types. The first section contains functions that may only be used to
generate root nodes, while the second section contains functions that
may only be used to generate child nodes. Nodes in both of these
sections may be used in both <code>node()</code> and
<code>node_td()</code> calls. The nodes mentioned in the third section
are only meant to be used for discrete-time simulations.</p>
</div>
</div>
<div id="simulating-crossectional-data" class="section level1">
<h1>Simulating crossectional data</h1>
<p>In the following Section we will illustrate how to use the
<code>simDAG</code> package to simulate more complex crossectional data.
Instead of using a made up artificial example, we will do this by
partially replicating a real Monte-Carlo simulation study by <span class="citation">Denz, Klaaßen-Mielke, and Timmesfeld (2023)</span>,
published in the prestigious peer-reviewed journal <em>Statistics in
Medicine</em>. Because this package strictly focuses on the data
generation step of Monte-Carlo studies and for reasons of brevity, we
will not reproduce the entire simulation study. Instead we will only
replicate the DGP used to generate the data for this study.</p>
<p><span class="citation">Denz, Klaaßen-Mielke, and Timmesfeld
(2023)</span> recently performed a neutral comparison study of multiple
different methods to estimate counterfactual survival curves from
crossectional observational data. In this Monte-Carlo simulation study
they wanted to investigate how different kinds of misspecifications of
nuisance models, which are used in some methods to estimate the
counterfactual survival curves, affect the estimates produced by the
different methods. To do this, a DGP was required that includes multiple
interrelated binary and continuous variables, as well as a
right-censored time-to-event variable.</p>
<p>In particular, the data sets they generated for each simulation run
included six covariates, two of which were binary (<span class="math inline">\(X_1, X_3\)</span>) and four of which were
continuous (<span class="math inline">\(X_2, X_4, X_5, X_6\)</span>). It
additionally included a binary treatment variable (<span class="math inline">\(Z\)</span>) and a right-censored time-to-event
outcome (<span class="math inline">\(T\)</span>). The two binary
covariates <span class="math inline">\(X_1\)</span> and <span class="math inline">\(X_3\)</span> followed a simple Bernoulli
distribution with a success probability of 0.5. <span class="math inline">\(X_2\)</span> was generated by a linear regression
model, dependent on <span class="math inline">\(X_3\)</span>. The two
continuous covariates <span class="math inline">\(X_4\)</span> and <span class="math inline">\(X_6\)</span> were standard normally distributed,
while <span class="math inline">\(X_5\)</span> was generated according
to a linear regression model dependent on <span class="math inline">\(X_6\)</span>. The treatment variable <span class="math inline">\(Z\)</span> followed a logistic regression model,
dependent on <span class="math inline">\(X_2\)</span>, <span class="math inline">\(X_3\)</span>, <span class="math inline">\(X_5\)</span> and <span class="math inline">\(X_6\)</span>, where <span class="math inline">\(X_2\)</span> was included as a squared term.
Finally, the outcome <span class="math inline">\(T\)</span> was
generated according to a Cox model, dependent on <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span>, <span class="math inline">\(X_4\)</span>, <span class="math inline">\(X_5\)</span> and <span class="math inline">\(Z\)</span>, where <span class="math inline">\(X_5\)</span> was included as a squared term. Data
for <span class="math inline">\(T\)</span> was generated using the
method by <span class="citation">(Bender, Augustin, and Blettner
2005)</span>, based on a Weibull distribution (<span class="math inline">\(\lambda=2, \gamma=2.4\)</span>). The time until
censoring was generated independently from a second Weibull distribution
(<span class="math inline">\(\lambda=1, \gamma=2\)</span>).</p>
<p>This DGP was used because it includes two confounders (<span class="math inline">\(X_2\)</span>, <span class="math inline">\(X_5\)</span>) for the causal effect of <span class="math inline">\(Z\)</span> on <span class="math inline">\(T\)</span>, which are correlated with other
non-confounding variables. The inclusion of non-linear relationships
allowed <span class="citation">Denz, Klaaßen-Mielke, and Timmesfeld
(2023)</span> to investigate different kinds of misspecified models.
More details on the DGP and the simulation study itself are given in the
original manuscript. To replicate the DGP of this study, the following
<code>DAG</code> definition may be used:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="fu">node</span>(<span class="fu">c</span>(<span class="st">&quot;X1&quot;</span>, <span class="st">&quot;X3&quot;</span>), <span class="at">type=</span><span class="st">&quot;rbernoulli&quot;</span>, <span class="at">p=</span><span class="fl">0.5</span>,</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>       <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>) <span class="sc">+</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="fu">node</span>(<span class="fu">c</span>(<span class="st">&quot;X4&quot;</span>, <span class="st">&quot;X6&quot;</span>), <span class="at">type=</span><span class="st">&quot;rnorm&quot;</span>, <span class="at">mean=</span><span class="dv">0</span>, <span class="at">sd=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;X2&quot;</span>, <span class="at">type=</span><span class="st">&quot;gaussian&quot;</span>, <span class="at">formula=</span><span class="sc">~</span><span class="fl">0.3</span> <span class="sc">+</span> X3<span class="sc">*</span><span class="fl">0.1</span>,</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>       <span class="at">error=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;X5&quot;</span>, <span class="at">type=</span><span class="st">&quot;gaussian&quot;</span>, <span class="at">formula=</span><span class="sc">~</span><span class="fl">0.3</span> <span class="sc">+</span> X6<span class="sc">*</span><span class="fl">0.1</span>,</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>       <span class="at">error=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;Z&quot;</span>, <span class="at">type=</span><span class="st">&quot;binomial&quot;</span>, <span class="at">formula=</span><span class="sc">~-</span><span class="fl">1.2</span> <span class="sc">+</span> <span class="fu">I</span>(X2<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span><span class="fu">log</span>(<span class="dv">3</span>)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>        <span class="sc">+</span> X3<span class="sc">*</span><span class="fu">log</span>(<span class="fl">1.5</span>) <span class="sc">+</span> X5<span class="sc">*</span><span class="fu">log</span>(<span class="fl">1.5</span>) <span class="sc">+</span> X6<span class="sc">*</span><span class="fu">log</span>(<span class="dv">2</span>),</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>       <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>) <span class="sc">+</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;T&quot;</span>, <span class="at">type=</span><span class="st">&quot;cox&quot;</span>, <span class="at">formula=</span><span class="sc">~</span>X1<span class="sc">*</span><span class="fu">log</span>(<span class="fl">1.8</span>) <span class="sc">+</span> X2<span class="sc">*</span><span class="fu">log</span>(<span class="fl">1.8</span>) <span class="sc">+</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>        X4<span class="sc">*</span><span class="fu">log</span>(<span class="fl">1.8</span>) <span class="sc">+</span> <span class="fu">I</span>(X5<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span><span class="fu">log</span>(<span class="fl">2.3</span>) <span class="sc">+</span> Z<span class="sc">*-</span><span class="dv">1</span>,</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>       <span class="at">surv_dist=</span><span class="st">&quot;weibull&quot;</span>, <span class="at">lambda=</span><span class="dv">2</span>, <span class="at">gamma=</span><span class="fl">2.4</span>,</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>       <span class="at">cens_dist=</span><span class="st">&quot;rweibull&quot;</span>,</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>       <span class="at">cens_args=</span><span class="fu">list</span>(<span class="at">shape=</span><span class="dv">1</span>, <span class="at">scale=</span><span class="dv">2</span>))</span></code></pre></div>
<p>As before, we can define the nodes <span class="math inline">\(X_1\)</span> and <span class="math inline">\(X_3\)</span> and the nodes <span class="math inline">\(X_4\)</span> and <span class="math inline">\(X_5\)</span> using a single call to
<code>node()</code>, because they have the same definition. Since only
directly supported regression models are required for this DGP, we were
able to use the <code>formula</code> argument to directly type out all
of the structural equations.</p>
<p>Plotting this <code>DAG</code> using the <code>plot()</code> method
produces the following output:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">plot</span>(dag, <span class="at">node_size=</span><span class="fl">0.3</span>, <span class="at">node_fill=</span><span class="st">&quot;grey&quot;</span>,</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>     <span class="at">node_text_fontface=</span><span class="st">&quot;italic&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The underlying structural equations are:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">summary</span>(dag)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt;   X1 ~ Bernoulli(0.5)</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt;   X3 ~ Bernoulli(0.5)</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#&gt;   X4 ~ N(0, 1)</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#&gt;   X6 ~ N(0, 1)</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#&gt;   X2 ~ N(0.3 + X3*0.1, 1)</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co">#&gt;   X5 ~ N(0.3 + X6*0.1, 1)</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co">#&gt;    Z ~ Bernoulli(logit(-1.2 + I(X2^2)*log(3) + X3*log(1.5) +</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#&gt;                   X5*log(1.5) + X6*log(2)))</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">#&gt; T[T] ~ (-(log(Unif(0, 1))/(2*exp(X1*log(1.8) + X2*log(1.8) +</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co">#&gt;          X4*log(1.8) + I(X5^2)*log(2.3) + Z*-1))))^(1/2.4)</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="co">#&gt; T[C] ~ rweibull(shape=1, scale=2)</span></span></code></pre></div>
<p>Finally, we can generate a single <code>data.table</code> from this
<code>DAG</code> using the <code>sim_from_dag()</code> function. The
first few rows of the generated data look like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;data.table&quot;</span>)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">sim_from_dag</span>(dag, <span class="at">n_sim=</span><span class="dv">500</span>)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">round</span>(dat, <span class="dv">3</span>))</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#&gt;       X1    X3     X4     X6     X2     X5     Z T_time T_status</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">#&gt;    &lt;num&gt; &lt;num&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt; &lt;num&gt;  &lt;num&gt;    &lt;num&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt; 1:     0     0 -0.646  1.186 -0.628  1.395     1  0.318        0</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; 2:     1     0  0.968 -2.368  0.101 -0.040     0  0.135        1</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; 3:     0     0  0.125  2.012  0.662  0.694     1  0.758        1</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; 4:     0     1 -0.142 -2.610 -0.826  0.588     1  1.100        1</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; 5:     0     0 -0.273  0.632  1.462  0.007     1  0.890        1</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt; 6:     1     1 -0.198  0.379  0.693  2.416     1  0.058        1</span></span></code></pre></div>
<p>Although only eight nodes were defined in the corresponding
<code>DAG</code>, it includes nine columns. The reason for this is that
nodes generated using <code>type=&quot;cox&quot;</code> by default generate two
columns: one for the observed time and one indicating whether the
observation is right-censored or not. This is the standard data format
for such time-to-event data and one of the reasons supplied node
functions are allowed to output multiple columns at the same time. This
of course also extends to custom user-defined node <code>type</code>s.
When no censoring distribution is supplied, it would also be possible to
return only the simulated time-to-event in a single column by setting
<code>as_two_cols=FALSE</code> in the <code>node()</code> call for <span class="math inline">\(T\)</span>.</p>
</div>
<div id="simulating-longitudinal-data-with-few-points-in-time" class="section level1">
<h1>Simulating longitudinal data with few points in time</h1>
<p>For many applications the desired DGP may contain one or more
variables that change over time. If that is the case, longitudinal data
must be generated. There are two approaches to do this using the
algorithm implemented in the proposed package: (1) defining one node per
point in time of interest and (2) constructing one node definition for
all points in time that should be considered simultaneously. In this
Section the first approach will be illustrated by replicating the DGP
that was used in the Monte-Carlo simulation study performed by <span class="citation">Gruber et al. (2015)</span>.</p>
<p>In their study, <span class="citation">Gruber et al. (2015)</span>
compared the efficiency of different methods of estimating inverse
probability weights for marginal structural models. Such models are
often used to estimate marginal causal effects of treatment-regimes from
longitudinal observational data with time-varying variables <span class="citation">(Hernán and Robins 2020)</span>. The main aim was to
quantify the benefits of using ensemble methods versus using traditional
methods, such as logistic regression models, when estimating the
required weights. Their DGP therefore required the inclusion of
time-varying variables. Below we focus on the DGP theses authors used in
their first simulation scenario.</p>
<p>Their DGP consisted of four variables: a binary treatment variable
<span class="math inline">\(A\)</span>, a binary unmeasured baseline
covariate <span class="math inline">\(U\)</span>, a continuous
confounder <span class="math inline">\(L\)</span> and a binary outcome
<span class="math inline">\(Y\)</span>. Since <span class="math inline">\(U\)</span> represents a baseline variable, it does
not vary over time. All other variables, however, were generated at two
distinct time points. <span class="math inline">\(L\)</span> and <span class="math inline">\(A\)</span> were generated for time <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, while the time-lagged outcome <span class="math inline">\(Y\)</span> was generated for times <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span>. For simplicity, <span class="math inline">\(A\)</span> was affected only by present and past
<span class="math inline">\(L\)</span> and not by previous values of
<span class="math inline">\(A\)</span> itself. <span class="math inline">\(L\)</span> on the other hand was caused by
previous values of itself and by <span class="math inline">\(A\)</span>
and <span class="math inline">\(U\)</span>. Finally, <span class="math inline">\(Y\)</span> is only caused by <span class="math inline">\(U\)</span>, meaning that neither the treatment nor
the confounder have any actual effect on the outcome. To generate
continuous child nodes they relied on linear regression models. For
binary child nodes, logistic regression models were used. A more
detailed description of the data generation process is given in the
original article <span class="citation">(Gruber et al. 2015)</span>. A
<code>DAG</code> object to define this DGP in the proposed package is
given below.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;U&quot;</span>, <span class="at">type=</span><span class="st">&quot;rbernoulli&quot;</span>, <span class="at">p=</span><span class="fl">0.5</span>, <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>) <span class="sc">+</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;L0&quot;</span>, <span class="at">type=</span><span class="st">&quot;gaussian&quot;</span>, <span class="at">formula=</span><span class="sc">~</span><span class="fl">0.1</span> <span class="sc">+</span> <span class="fl">0.6</span><span class="sc">*</span>U,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>       <span class="at">error=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;A0&quot;</span>, <span class="at">type=</span><span class="st">&quot;binomial&quot;</span>, <span class="at">formula=</span><span class="sc">~-</span><span class="fl">0.4</span> <span class="sc">+</span> <span class="fl">0.6</span><span class="sc">*</span>L0,</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>       <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>) <span class="sc">+</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;Y1&quot;</span>, <span class="at">type=</span><span class="st">&quot;binomial&quot;</span>, <span class="at">formula=</span><span class="sc">~-</span><span class="fl">3.5</span> <span class="sc">+</span> <span class="sc">-</span><span class="fl">0.9</span><span class="sc">*</span>U,</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>       <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>) <span class="sc">+</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;L1&quot;</span>, <span class="at">type=</span><span class="st">&quot;gaussian&quot;</span>, <span class="at">formula=</span><span class="sc">~</span><span class="fl">0.5</span> <span class="sc">+</span> <span class="fl">0.02</span><span class="sc">*</span>L0 <span class="sc">+</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>        <span class="fl">0.5</span><span class="sc">*</span>U <span class="sc">+</span> <span class="fl">1.5</span><span class="sc">*</span>A0, <span class="at">error=</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;A1&quot;</span>, <span class="at">type=</span><span class="st">&quot;binomial&quot;</span>, <span class="at">formula=</span><span class="sc">~-</span><span class="fl">0.4</span> <span class="sc">+</span> <span class="fl">0.02</span><span class="sc">*</span>L0 <span class="sc">+</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>        <span class="fl">0.58</span><span class="sc">*</span>L1, <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>) <span class="sc">+</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;Y2&quot;</span>, <span class="at">type=</span><span class="st">&quot;binomial&quot;</span>, <span class="at">formula=</span><span class="sc">~-</span><span class="fl">2.5</span> <span class="sc">+</span> <span class="fl">0.9</span><span class="sc">*</span>U,</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>       <span class="at">output=</span><span class="st">&quot;numeric&quot;</span>)</span></code></pre></div>
<p>Shown graphically, the <code>DAG</code> looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">plot</span>(dag, <span class="at">node_size=</span><span class="fl">0.2</span>, <span class="at">node_fill=</span><span class="st">&quot;grey&quot;</span>,</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>     <span class="at">node_text_fontface=</span><span class="st">&quot;italic&quot;</span>, <span class="at">layout=</span><span class="st">&quot;in_circle&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The structural equations can again be printed using the
<code>summary()</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">summary</span>(dag)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co">#&gt; A DAG object using the following structural equations:</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">#&gt;  U ~ Bernoulli(0.5)</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">#&gt; L0 ~ N(0.1 + 0.6*U, 1)</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">#&gt; A0 ~ Bernoulli(logit(-0.4 + 0.6*L0))</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">#&gt; Y1 ~ Bernoulli(logit(-3.5 + -0.9*U))</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">#&gt; L1 ~ N(0.5 + 0.02*L0 + 0.5*U + 1.5*A0, 1)</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="co">#&gt; A1 ~ Bernoulli(logit(-0.4 + 0.02*L0 + 0.58*L1))</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a><span class="co">#&gt; Y2 ~ Bernoulli(logit(-2.5 + 0.9*U))</span></span></code></pre></div>
<p>Finally, we can call the <code>sim_from_dag()</code> function on this
<code>DAG</code> to generate some data:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">sim_from_dag</span>(dag, <span class="at">n_sim=</span><span class="dv">1000</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="fu">head</span>(dat)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#&gt;        U         L0    A0    Y1         L1    A1    Y2</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co">#&gt;    &lt;num&gt;      &lt;num&gt; &lt;num&gt; &lt;num&gt;      &lt;num&gt; &lt;num&gt; &lt;num&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co">#&gt; 1:     0  1.3086008     0     0 -0.1642422     1     0</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="co">#&gt; 2:     1 -0.4978996     1     0  3.2424318     0     0</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co">#&gt; 3:     1  0.5125773     1     0  2.4114821     1     0</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="co">#&gt; 4:     1  1.1811591     1     0  3.2285778     0     1</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co">#&gt; 5:     1  1.3826790     1     0  1.7878382     1     0</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co">#&gt; 6:     1 -0.3077301     0     0  1.1737307     0     0</span></span></code></pre></div>
<p>Because the variables <span class="math inline">\(A\)</span>, <span class="math inline">\(L\)</span> and <span class="math inline">\(Y\)</span> should be generated at different points
in time, we have to include one node definition per variable per point
in time to get an appropriate <code>DAG</code>. Apart from that the
syntax is exactly the same as it was when generating crossectional data.
More points in time could be added by simply adding more calls to
<code>node()</code> to the <code>DAG</code> object, using appropriate
regression models. The main advantage of this method is that it allows
flexible changes of the DGP over time. However, the obvious shortcoming
is that it does not easily extend to scenarios with many points in time.
Although the authors only considered three time-varying variables and
two distinct points in time here, the <code>DAG</code> definition is
already quite cumbersome. For every further point in time, three new
calls to <code>node()</code> would be necessary. If hundreds of points
in time should be considered, using this method is essentially
in-feasible. To circumvent these problems we describe a slightly
different way of generating longitudinal data below.</p>
</div>
<div id="simulating-longitudinal-data-with-many-points-in-time" class="section level1">
<h1>Simulating longitudinal data with many points in time</h1>
<div id="formal-description" class="section level2">
<h2>Formal description</h2>
<p>Instead of defining each node for every point in time separately, it
is often possible to define the structural equations in a generic
time-dependent fashion, so that the same equation can be applied at each
point in time, simplifying the workflow considerably. The result is the
description of a specific stochastic process. For example, consider a
very simple DAG with only one time-dependent node <span class="math inline">\(Y\)</span> at three points in time, <span class="math inline">\(t \in \{0, 1, 2\}\)</span>:</p>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>In this DAG, <span class="math inline">\(Y_t\)</span> is only caused
by values of itself at <span class="math inline">\(t-1\)</span>. Suppose
that <span class="math inline">\(Y\)</span> is a binary event indicator
that is zero for everyone at <span class="math inline">\(t = 0\)</span>.
At every point in time <span class="math inline">\(t\)</span>, <span class="math inline">\(Y\)</span> is set to 1 with a probability of 0.01.
Once <span class="math inline">\(Y\)</span> is set to 1, it never
changes back to 0. The following structural equation may be used to
describe this DAG:</p>
<p><span class="math display">\[
    Y_t \sim Bernoulli(P_Y(t)),
\]</span></p>
<p>where</p>
<p><span class="math display">\[
    P_Y(t) =
    \begin{cases}
        0 &amp; \text{if} \quad t = 0 \\
        1 &amp; \text{if} \quad Y_{t-1} = 1 \\
        0.01, &amp; \text{otherwise}
    \end{cases}.
\]</span></p>
<p>The number of points in time could be increased by an arbitrary
number and the same structural equation could still be used. Note that
the time points may stand for any period of time, such as minutes, days
or years. This is of course a trivial example, but this approach may
also be used to define very complex DGPs, as illustrated below. For
example, arbitrary dependencies on other variables measured at the same
time or at any earlier time may be used when defining a node. To
generate data from this type of DAG, the same algorithm as described in
the first Section may be used. Since only discrete points in time are
considered, this type of simulation has also been called
<em>discrete-time simulation</em> <span class="citation">(Tang, Leu, and
Abbass 2020)</span> or <em>dynamic microsimulation</em> <span class="citation">(Spooner et al. 2021)</span> in the literature and is
closely related to <em>discrete-event simulation</em> <span class="citation">(Banks et al. 2014)</span>.</p>
</div>
<div id="a-simple-example" class="section level2">
<h2>A simple example</h2>
<p>To generate data for the simple example considered above in the
proposed package, we first have to define an appropriate
<code>DAG</code> object as before. This can be done using the
<code>node_td()</code> function with <code>type=&quot;time_to_event&quot;</code>
as shown below.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="cn">Inf</span>)</span></code></pre></div>
<p>By default, the value of node defined using
<code>type=&quot;time_to_event&quot;</code> is 0 for all individuals at <span class="math inline">\(t = 0\)</span>. The <code>prob_fun</code> argument
defines the function that determines the occurrence probability at each
point in time. It is set to 0.01 here, indicating that for all
individuals and regardless of the value of <span class="math inline">\(t\)</span> the probability of experiencing the
event is constant. Usually this argument will be passed an appropriate
function to generate the occurrence probability for each individual at
each point in time separately, but this is not necessary yet. By setting
the <code>event_duration</code> argument to <code>Inf</code>, we are
indicating that the all events have an infinite duration, making the
first event the final event for each person. In contrast to before, the
<code>sim_discrete_time()</code> function now has to be used to generate
data from this <code>DAG</code> object, because it contains a
time-varying node:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">1000</span>, <span class="at">max_t=</span><span class="dv">80</span>)</span></code></pre></div>
<p>The <code>max_t</code> argument specifies how many points in time
should be simulated. Instead of just three points in time we consider 80
here. Contrary to the <code>sim_from_dag()</code> function, the
<code>sim_discrete_time()</code> function does not return a single
<code>data.table</code>. Instead it returns a <code>simDT</code> object,
which usually has to be processed further using the
<code>sim2data()</code> function to be useful. In this case, however, it
is enough to simply extract the last state of the simulation to get all
the information we need. This last simulation state is stored in the
<code>$data</code> parameter of the <code>simDT</code> object:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">head</span>(sim<span class="sc">$</span>data)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="co">#&gt;      .id Y_event Y_time</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt;  &lt;lgcl&gt;  &lt;int&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#&gt; 1:     1   FALSE     NA</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#&gt; 2:     2    TRUE     56</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; 3:     3    TRUE      8</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; 4:     4    TRUE     26</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; 5:     5   FALSE     NA</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt; 6:     6    TRUE     58</span></span></code></pre></div>
<p>As specified, the simulation contains only the variable <span class="math inline">\(Y\)</span>, split into two columns. The first is
called <code>Y_event</code> and is a binary indicator of whether the
individual is currently experiencing an event. The second column called
<code>Y_time</code> shows the time at which that event happened, or is
set to <code>NA</code> if there is no event currently happening. Since
every event is final, this is all information that was generated here.
Individuals with a value of <code>NA</code> in <code>Y_time</code> can
be considered right-censored at <span class="math inline">\(t =
80\)</span>. In this trivial example, it would be a lot easier to
generate equivalent data by sampling from an appropriate parametric
distributions. The following Section will illustrate the benefits of the
approach using a more involved example.</p>
</div>
<div id="simulating-adverse-events-after-covid-19-vaccination" class="section level2">
<h2>Simulating adverse events after Covid-19 vaccination</h2>
<p>Suppose that we want to generate data for the Covid-19 pandemic,
containing individual level information about Covid-19 vaccinations
denoted by <span class="math inline">\(A\)</span> and the development of
an acute myocarditis denoted by <span class="math inline">\(Y\)</span>.
Different individuals get vaccinated at different times, possible
multiple times. Additionally, they might experience zero or multiple
cases of myocarditis, also at different times. Both variables are
therefore time-dependent binary variables, which are related to one
another. If the target of interest is to estimate the effect of the
vaccination on the time until the occurrence of a myocarditis, the
vaccination may be considered a time-dependent variable and the
myocarditis as a non-terminal, possibly recurrent, time-to-event
outcome. This setup was of interest to <span class="citation">Denz et
al. (2025)</span>, who performed a Monte-Carlo simulation study to
investigate the impact of linkage errors when estimating vaccine-safety
from observational data. Below we will illustrate a simplified version
of the DGP used therein.</p>
<p>For simplicity, we will make multiple simplifying assumptions that
were not made in the original simulation study. First, we assume that
the probability of being vaccinated and the base probability of
developing a myocarditis are constant over time and equal for all
individuals. The only risk factor for developing a myocarditis in this
example is the Covid-19 vaccination itself. More precisely, the
structural equation for the myocarditis node at <span class="math inline">\(t\)</span> is given by:</p>
<p><span class="math display">\[
    Y_t \sim Bernoulli(P_{Y}(t)),
\]</span></p>
<p>with:</p>
<p><span class="math display">\[
    P_{Y}(t) =
    \begin{cases}
        P_{Y0} \cdot RR_{A}, &amp; \text{if } t \in  \left[T_{A}(t),
T_{A}(t) + d_{risk}\right] \\
        P_{Y0}, &amp; \text{otherwise}
    \end{cases},
\]</span></p>
<p>where <span class="math inline">\(P_{Y0}\)</span> denotes the base
probability of developing a myocarditis, <span class="math inline">\(T_{A}(t)\)</span> denotes the time of the last
performed vaccination and <span class="math inline">\(d_{risk}\)</span>
defines the duration after the vaccination in which the risk of
developing a myocarditis is elevated by <span class="math inline">\(RR_{A}\)</span>. In this particular case, each
<span class="math inline">\(t\)</span> will represent a single day.
Similarly, the vaccination node can be described formally as:</p>
<p><span class="math display">\[
    A_t \sim Bernoulli(P_{A}(t)),
\]</span></p>
<p>with:</p>
<p><span class="math display">\[
    P_{A}(t) =
    \begin{cases}
        1, &amp; \text{if } t \in  \left[T_{A}(t), T_A(t) + 20 \right]
\\
        0, &amp; \text{if } t \in  \left[T_{A}(t) + 21, T_A(t) +
150\right] \\
        P_{A0}, &amp; \text{otherwise}
    \end{cases},
\]</span></p>
<p>where <span class="math inline">\(P_{A0}\)</span> denotes the base
probability of getting vaccinated. The Figure below illustrates the
result of applying these structural equations to a fictional person who
gets vaccinated at <span class="math inline">\(t = 100\)</span>.</p>
<div class="figure" style="text-align: center">
<img src="data:image/png;base64,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" alt="A simple graph showing $P_A(t)$ and $P_Y(t)$ for a fictional individual who got vaccinated once at $t = 100$, with $P_{A0} = 0.01$, $P_{Y0} = 0.005$, $d_{risk} = 20$ and $RR_A = 3.24$." width="600" />
<p class="caption">
A simple graph showing <span class="math inline">\(P_A(t)\)</span> and
<span class="math inline">\(P_Y(t)\)</span> for a fictional individual
who got vaccinated once at <span class="math inline">\(t = 100\)</span>,
with <span class="math inline">\(P_{A0} = 0.01\)</span>, <span class="math inline">\(P_{Y0} = 0.005\)</span>, <span class="math inline">\(d_{risk} = 20\)</span> and <span class="math inline">\(RR_A = 3.24\)</span>.
</p>
</div>
<p>The following code may be used to define this DGP:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A) {</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>}</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span></code></pre></div>
<p>First, we define a function that calculates <span class="math inline">\(P_Y(t)\)</span> at each simulated day for all
individuals, called <code>prob_myoc()</code>. This function simply
checks whether the binary event indicator of the vaccination event,
<code>&quot;A_event&quot;</code>, is currently <code>TRUE</code> and multiplies
the baseline probability of developing a myocarditis <span class="math inline">\(P_{Y0}\)</span> with the relative risk if this is
the case. Otherwise it just returns the baseline probability directly.
This function is then passed directly to the <code>prob_fun</code>
argument in the <code>node_td()</code> call when defining the
myocarditis node. For this to be a sensible strategy, we need to ensure
that <code>&quot;A_event&quot;</code> is only <code>TRUE</code> when a person is
currently at elevated risk for a myocarditis, as defined in the earlier
Equation. In other words, <code>&quot;A_event&quot;</code> should not actually be
an indicator of whether someone just received a vaccination, but an
indicator of whether the person is currently in the risk period of 20
days following the vaccination. We can achieve this by setting the
<code>event_duration</code> parameter in the node definition of the
vaccination node to 20, meaning that the vaccination node will equal 1
for 20 days after a vaccination was performed. This argument is a direct
feature of the <code>node_time_to_event()</code> function, which is
called internally whenever <code>type=&quot;time_to_event&quot;</code> is used in
a time-dependent node.</p>
<p>The base probability for the vaccination and for the myocarditis
events are set to the arbitrary values of 0.01 and 0.005 respectively.
<span class="math inline">\(RR_{A}\)</span> is set to 3.24, which is the
value used in the actual simulation study by <span class="citation">Denz
et al. (2025)</span>. The <code>immunity_duration</code> parameter used
for the vaccination node additionally specifies that a person will not
receive another vaccination in the first 150 days after a vaccination
was performed. More specifically, these settings ensure that
<code>&quot;A_event&quot;</code> is set to <code>FALSE</code> for 130 days after
the <code>event_duration</code> of 20 days is over. This is another
feature of <code>&quot;time_to_event&quot;</code> nodes. To run the simulation for
two simulated years, the following code may be used:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">10000</span>, <span class="at">max_t=</span><span class="dv">365</span><span class="sc">*</span><span class="dv">2</span>)</span></code></pre></div>
<p>Since both of the included variables change over time and may have
multiple events, it is not appropriate to just look at the last state of
the simulation in this case. Instead we will have to use the
<code>sim2data()</code> function to obtain a useful dataset. The
following code may be used to get a dataset in the <em>start-stop</em>
format:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>, <span class="at">target_event=</span><span class="st">&quot;Y&quot;</span>,</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>                <span class="at">keep_only_first=</span><span class="cn">TRUE</span>, <span class="at">overlap=</span><span class="cn">TRUE</span>)</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="fu">head</span>(dat)</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    57  FALSE   TRUE</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="co">#&gt; 2:     2     1    21  FALSE  FALSE</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="co">#&gt; 3:     2    21    38   TRUE   TRUE</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="co">#&gt; 4:     3     1    50  FALSE  FALSE</span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a><span class="co">#&gt; 5:     3    50    70   TRUE  FALSE</span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a><span class="co">#&gt; 6:     3    70   272  FALSE  FALSE</span></span></code></pre></div>
<p>In this format, there are multiple rows per person, corresponding to
periods of time in which all variables stayed the same. These intervals
are defined by the <code>start</code> column (time at which the period
starts) and <code>stop</code> columns (time at which the period ends).
The <code>overlap</code> argument specifies whether these intervals
should be overlapping or not. By setting <code>target_event=&quot;Y&quot;</code>,
the function treats the <code>Y</code> node as the outcome instead of as
another time-dependent covariate. The resulting data is in exactly the
format needed to fit standard time-to-event models, such as a Cox model
with time-varying covariates <span class="citation">(Z. Zhang et al.
2018)</span>. Using the <code>survival</code> package <span class="citation">(Therneau 2024)</span>, we can do this using the
following code:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;survival&quot;</span>)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>mod <span class="ot">&lt;-</span> <span class="fu">coxph</span>(<span class="fu">Surv</span>(start, stop, Y) <span class="sc">~</span> A, <span class="at">data=</span>dat)</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="fu">summary</span>(mod)</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="co">#&gt; coxph(formula = Surv(start, stop, Y) ~ A, data = dat)</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co">#&gt;   n= 25020, number of events= 9871 </span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="co">#&gt;          coef exp(coef) se(coef)     z Pr(&gt;|z|)    </span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a><span class="co">#&gt; ATRUE 1.15906   3.18693  0.02377 48.76   &lt;2e-16 ***</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="co">#&gt; ---</span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a><span class="co">#&gt;       exp(coef) exp(-coef) lower .95 upper .95</span></span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a><span class="co">#&gt; ATRUE     3.187     0.3138     3.042     3.339</span></span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a><span class="co">#&gt; Concordance= 0.58  (se = 0.002 )</span></span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a><span class="co">#&gt; Likelihood ratio test= 1928  on 1 df,   p=&lt;2e-16</span></span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a><span class="co">#&gt; Wald test            = 2378  on 1 df,   p=&lt;2e-16</span></span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a><span class="co">#&gt; Score (logrank) test = 2648  on 1 df,   p=&lt;2e-16</span></span></code></pre></div>
<p>Because the DGP fulfills all assumptions of the Cox model and the
sample size is very large, the resulting hazard ratio is close to the
relative risk of 3.24 that were specified in the <code>DAG</code>
object. Other types of models, such as discrete-time survival models,
may require different data formats <span class="citation">(Tutz and
Schmid 2016)</span>. Because of this, the <code>sim2data()</code>
function also supports the transformation into <em>long-</em> and
<em>wide-</em> format data.</p>
<p>Above we assumed that the presence of a myocarditis event has no
effect on whether a person gets vaccinated or not. In reality, it is
unlikely that a person who is currently experiencing a myocarditis would
get a Covid-19 vaccine. We can include this into the DGP by modifying
the <code>prob_fun</code> argument when defining the vaccination node as
shown below:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>prob_vacc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0) {</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>Y_event, <span class="dv">0</span>, P_0)</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>}</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_vacc,</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>, <span class="at">P_0=</span><span class="fl">0.01</span>) <span class="sc">+</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>,</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">80</span>)</span></code></pre></div>
<p>In this extension, the probability of getting vaccinated is set to 0
whenever the respective person is currently experiencing a myocarditis
event. By additionally setting the <code>event_duration</code> parameter
of the myocarditis node to the arbitrary value of 80, we are defining
that in the 80 days after experiencing the event there will be no
vaccination for that person. Data could be generated and transformed
using the same code as before.</p>
</div>
<div id="additionally-supported-features" class="section level2">
<h2>Additionally supported features</h2>
<p>The example shown above illustrates only a small fraction of the
possible features that could be included into the DGP using the
discrete-time simulation algorithm implemented in the proposed package.
Below we name more features that could theoretically be added to the
DGP. Examples for how to actually implement these extensions are given
in the appendix.</p>
<ul>
<li><p><strong>Time-Dependent Probabilities and Effects</strong>: In the
example above both the base probabilities and the relative risks were
always set to a constant, regardless of the simulation time. This may
also be changed by re-defining the <code>prob_fun</code> argument to
have a named argument called <code>sim_time</code>. Internally, the
current time of the simulation will then be passed directly to the
<code>prob_fun</code>, allowing users to define any
time-dependencies.</p></li>
<li><p><strong>Non-Linear Effects</strong>: Above, we only considered
the simple scenario in which the probability of an event after the
occurrence of another event follows a simple step function, e.g., it is
set to <span class="math inline">\(P_0\)</span> in general and increased
by a fixed factor in a fixed duration after an event. This may also be
changed by using more complex definitions of <code>prob_fun</code> that
are not based only on the <code>_event</code> column of the exposure,
but directly on the time of occurrence.</p></li>
<li><p><strong>Adding more Binary Time-Dependent Variables</strong>:
Only two time-dependent variables were considered in the example. It is
of course possible to add as many further variables as desired by the
user by simply adding more appropriate <code>node_td()</code> calls to
the <code>DAG</code> object. Both the <code>sim_discrete_time()</code>
function and the <code>sim2data()</code> function will still work
exactly as described earlier.</p></li>
<li><p><strong>Adding Baseline Covariates</strong>: It is of course also
possible to define a <code>DAG</code> that contains both
time-independent and time-dependent variables at the same time. This can
be achieved by adding nodes with the <code>node()</code> and
<code>node_td()</code> function. Data for the time-independent variables
will then be generated first (at <span class="math inline">\(t =
0\)</span>) and the time-dependent simulation will be performed as
before, albeit possibly dependent on the time-independent
variables.</p></li>
<li><p><strong>Adding Categorical Time-Dependent Variables</strong>:
Sometimes it may not be appropriate to describe a time-varying variable
using only two classes. For theses cases, the proposed package also
includes the <code>&quot;competing_events&quot;</code> node type, which is very
similar to the <code>&quot;time_to_event&quot;</code> node type. The only
difference is that instead of Bernoulli trials multinomial trials are
performed at each point in time for all individuals, allowing the
generation of mutually exclusive events.</p></li>
<li><p><strong>Adding Arbitrarily Distributed Time-Dependent
Variables</strong>: As in the <code>sim_from_dag()</code> function, any
kind of function may be used as a <code>type</code> for time-dependent
variables. By appropriately defining those, it is possible to generate
count and continuous time-varying variables as well.</p></li>
<li><p><strong>Adding Ordered Events</strong>: Some events should only
be possible once something else has already happened. For example, a
person usually cannot receive a PhD before graduating high school. This
type of data may also be generated, again by appropriately specifying
the required probability functions.</p></li>
</ul>
<p>All of the mentioned and shown features may of course be used in
arbitrary combinations. Additionally, the list above is not meant to be
exhaustive. It is merely supposed to highlight how versatile the
implemented approach is.</p>
</div>
<div id="computational-considerations" class="section level2">
<h2>Computational considerations</h2>
<p>Although the discrete-time simulation procedure described above is
incredibly flexible, it is also very computationally expensive
theoretically. For example, when using nodes of type
<code>&quot;time_to_event&quot;</code>. as shown above, the program has to
re-calculate the event probabilities at each point in time, for every
individual and for every node. Increasing either the number of nodes,
the number of time points or the number of considered individuals
therefore non-linearly increases the number of required computations.
This fact, together with the lack of available appropriate software
packages, is probably the main reason this type of simulation strategy
is rarely used in Monte-Carlo simulation studies. Since Monte-Carlo
studies often require thousands of replications with hundreds of
different scenarios, even a runtime of a few seconds to generate a
dataset may be too long to keep the simulation computationally
feasible.</p>
<p>The presented implementation was therefore designed explicitly to be
as fast as possible. To ensure that it can be run on multiple processing
cores in parallel, it is additionally designed to use as little random
access memory (RAM) as possible. As all other code in this package, it
exclusively uses the <code>data.table</code> package <span class="citation">(Barrett et al. 2024)</span> to perform most required
computations. The <code>data.table</code> package is arguably the best
choice for doing data wrangling in the <code>R</code> ecosystem in terms
of computational efficiency and has similar performance as corresponding
software libraries in <code>R</code> and <code>Julia</code> <span class="citation">(Chiou, Xu, and Huang 2023)</span>. The proposed
package additionally relies on a few tricks to keep the amount of memory
used small. For example, when using nodes of type
<code>&quot;time_to_event&quot;</code>, by default not every state of the
simulation is saved. Only the times at which an event occurred are
recorded. This information is then efficiently pieced together in the
<code>sim2data()</code> function when creating the actual dataset.</p>
<p>Although none of these code optimizations can entirely overcome the
inherent computational complexity of the approach, they do ensure that
the usage of this method is feasible to generate reasonably large data
with many points in time on a regular office computer. For example,
generating a dataset with 1000 individuals and 730 distinct points in
time from the first <code>DAG</code>, shown in the Section containing
the Covid example, takes only 1.11 seconds on average on the authors
personal computer, using a single processing core (Intel(R) Core(TM)
i7-9700 CPU @ 3.00GHz, 32GB RAM). It is, however, also important to note
that the runtime highly depends on how efficient the functions supplied
to the <code>prob_fun</code> arguments are written as well.</p>
<p>Below we give some additional limited code to illustrate the
increased runtime of the <code>sim_discrete_time()</code> function with
increasing <code>n_sim</code> and increasing <code>max_t</code> values.
As an example, we use the first DGP shown in the Section on the Covid
example to generate some data for multiple different values of each
argument. We include calls to the <code>sim2data()</code> function in
the runtime calculations, because calling this function is necessary to
obtain usable data and as such should be considered part of the DGP. The
runtime is calculated using the <code>microbenchmark</code> package
<span class="citation">(Mersmann 2023)</span>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: This part of the code is not run here, because it would take too long</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="co"># on CRAN and would introduce another dependency on the &quot;microbenchmark&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="co"># package. Results may also vary depending on the hardware this is run on.</span></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A) {</span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>}</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>run_example <span class="ot">&lt;-</span> <span class="cf">function</span>(n, max_t) {</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a>  dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>    <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>            <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>    <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a>            <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span>n, <span class="at">max_t=</span>max_t)</span>
<span id="cb22-21"><a href="#cb22-21" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>, <span class="at">target_event=</span><span class="st">&quot;Y&quot;</span>,</span>
<span id="cb22-23"><a href="#cb22-23" tabindex="-1"></a>                  <span class="at">keep_only_first=</span><span class="cn">TRUE</span>, <span class="at">overlap=</span><span class="cn">TRUE</span>)</span>
<span id="cb22-24"><a href="#cb22-24" tabindex="-1"></a>}</span>
<span id="cb22-25"><a href="#cb22-25" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">1000</span>, <span class="dv">10000</span>, <span class="dv">100000</span>)</span>
<span id="cb22-27"><a href="#cb22-27" tabindex="-1"></a>max_t <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">1000</span>, <span class="dv">10000</span>)</span>
<span id="cb22-28"><a href="#cb22-28" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">max_t=</span><span class="fu">rep</span>(max_t, <span class="at">each=</span><span class="fu">length</span>(n)),</span>
<span id="cb22-30"><a href="#cb22-30" tabindex="-1"></a>                     <span class="at">n=</span><span class="fu">rep</span>(n), <span class="at">time=</span><span class="cn">NA</span>)</span>
<span id="cb22-31"><a href="#cb22-31" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="fu">nrow</span>(params))) {</span>
<span id="cb22-33"><a href="#cb22-33" tabindex="-1"></a>  n_i <span class="ot">&lt;-</span> params<span class="sc">$</span>n[i]</span>
<span id="cb22-34"><a href="#cb22-34" tabindex="-1"></a>  max_t_i <span class="ot">&lt;-</span> params<span class="sc">$</span>max_t[i]</span>
<span id="cb22-35"><a href="#cb22-35" tabindex="-1"></a></span>
<span id="cb22-36"><a href="#cb22-36" tabindex="-1"></a>  bench <span class="ot">&lt;-</span> <span class="fu">microbenchmark</span>(<span class="fu">run_example</span>(<span class="at">n=</span>n_i, <span class="at">max_t=</span>max_t_i),</span>
<span id="cb22-37"><a href="#cb22-37" tabindex="-1"></a>                          <span class="at">times=</span><span class="dv">1</span>)</span>
<span id="cb22-38"><a href="#cb22-38" tabindex="-1"></a>  params<span class="sc">$</span>time[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(bench<span class="sc">$</span>time <span class="sc">/</span> <span class="dv">1000000000</span>)</span>
<span id="cb22-39"><a href="#cb22-39" tabindex="-1"></a>}</span>
<span id="cb22-40"><a href="#cb22-40" tabindex="-1"></a></span>
<span id="cb22-41"><a href="#cb22-41" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">within</span>(params, {</span>
<span id="cb22-42"><a href="#cb22-42" tabindex="-1"></a>  max_t <span class="ot">&lt;-</span> <span class="fu">factor</span>(max_t)</span>
<span id="cb22-43"><a href="#cb22-43" tabindex="-1"></a>})</span>
<span id="cb22-44"><a href="#cb22-44" tabindex="-1"></a></span>
<span id="cb22-45"><a href="#cb22-45" tabindex="-1"></a><span class="fu">ggplot</span>(params, <span class="fu">aes</span>(<span class="at">x=</span>n, <span class="at">y=</span>time, <span class="at">color=</span>max_t)) <span class="sc">+</span></span>
<span id="cb22-46"><a href="#cb22-46" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb22-47"><a href="#cb22-47" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb22-48"><a href="#cb22-48" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb22-49"><a href="#cb22-49" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x=</span><span class="st">&quot;n_sim&quot;</span>, <span class="at">y=</span><span class="st">&quot;Runtime in Seconds&quot;</span>, <span class="at">color=</span><span class="st">&quot;max_t&quot;</span>) <span class="sc">+</span></span>
<span id="cb22-50"><a href="#cb22-50" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">labels=</span>scales<span class="sc">::</span><span class="fu">label_comma</span>(),</span>
<span id="cb22-51"><a href="#cb22-51" tabindex="-1"></a>                     <span class="at">transform=</span><span class="st">&quot;log10&quot;</span>) <span class="sc">+</span></span>
<span id="cb22-52"><a href="#cb22-52" tabindex="-1"></a>  <span class="fu">scale_y_log10</span>()</span></code></pre></div>
<p><img src="data:image/png;base64,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" width="600" style="display: block; margin: auto;" /></p>
<p>The runtime increases more sharply with higher values of
<code>max_t</code> than it does with higher values of
<code>n_sim</code>, because each additional considered point in time
internally translates to one more iteration in an <code>R</code>
<code>for</code> loop, while each additional considered individual
translates to one more row in the generated data, which is processed
using optimized <code>data.table</code> code directly.</p>
</div>
</div>
<div id="discussion" class="section level1">
<h1>Discussion</h1>
<p>In this article we presented the <code>simDAG</code> <code>R</code>
package and illustrated how it can be used to generate various forms of
artificial data that may be required for Monte-Carlo simulation studies.
In particular, we showed how the package may be used to generate
crossectional and longitudinal data with multiple variables of different
data types, non-linear effects and arbitrary causal dependencies. We
showed how similar the syntax is for very different kinds of DGP and how
closely the required code resembles the actual underlying structural
equations when using built-in node types. Because the package is based
on defining a DAG to describe the DGP, it lends itself particularly well
to simulation studies dealing with causal inference, but it is by no
means limited to applications in this field, as shown in the second to
last Section of the article.</p>
<p>In addition to the main data generation functions, the package also
includes multiple functions to facilitate the accurate description of
the underlying DGP. Such descriptions are of great importance to
facilitate both understanding and reproducibility of simulation studies,
as emphasized in the literature <span class="citation">(Morris, White,
and Crowther 2019; Cheng et al. 2016)</span>. Among these are the
<code>plot.DAG()</code> function, that was used throughout the article
to graphically display the defined <code>DAG</code> objects. While this
function is useful on its own, some users may prefer to use one of the
many other options to display DAGs in <code>R</code> <span class="citation">(Pitts and Fowler 2024)</span>. To make this easier for
users the package also contains the <code>dag2matrix()</code> function,
which returns the underlying adjacency matrix of a <code>DAG</code>
object and the <code>as.igraph.DAG()</code> function for direct
integration with the <code>igraph</code> <code>R</code> package <span class="citation">(Csárdi et al. 2024)</span>. Additionally, the
<code>summary.DAG()</code> method may be used to directly print the used
structural equations, as shown throughout the article.</p>
<p>The most distinguishing feature of the package is its capability of
carrying out discrete-time simulations to generate longitudinal data
with hundreds of points in time in a suitable amount of time. While
other packages, such as the <code>simcausal</code> package <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span>
offer similar features to generate crossectional data, its’
implementation for generation of longitudinal data is very different
from the proposed package. In <code>simcausal</code> a new node is
defined for each point in time internally. Although the user has direct
access to each of these nodes (and therefore to each value at any point
in time), the provided formula interface does not naturally support the
definition of nodes with events that occur at some point in time and
last for a certain amount of time. This can be done with little effort
in the <code>simDAG</code> package using the provided
<code>&quot;time_to_event&quot;</code> node type.</p>
<p>This type of node can then be used to specify outcomes or to specify
binary time-varying covariates, as illustrated in the main text where we
used two such nodes to describe both the Covid-19 vaccination status and
the associated adverse event. Using just this node type it is therefore
possible to define DGPs including a time-to-event outcome (possibly with
recurrent events) with multiple time-varying covariates. While there are
multiple other methods to generate some forms of time-to-event data with
time-varying covariates <span class="citation">(Hendry 2013; Austin
2012; Huang et al. 2020; Ngwa et al. 2022)</span>, most of them require
strict parametrizations or do not support the use of multiple,
arbitrarily distributed time-varying variables. Additionally, neither of
these methods allows the inclusion of recurrent events or competing
events. None of these restrictions apply to the discrete-time simulation
approach.</p>
<p>However, the method also has two main disadvantages. First, it is a
lot more computationally expensive than other methods, and secondly it
does usually require the user to define appropriate functions to
generate the time- and individual specific probabilities per node.
Although the inherent computational complexity cannot be removed, it is
alleviated in the implementation of this package through the use of
optimized code and the <code>data.table</code> back-end <span class="citation">(Barrett et al. 2024)</span>. As shown in the article,
the presented implementation allows generation of large datasets in a
reasonable amount of time. A computationally more efficient alternative
not considered in this package would be <em>discrete-event
simulation</em> <span class="citation">(Banks et al. 2014)</span>, in
which the time until the next event is modeled directly instead of
simulating the entire process over time. Performing such simulations is,
however, usually a lot more demanding both conceptually and in terms of
required software development <span class="citation">(X. Zhang
2018)</span>. The burden of specifying appropriate input to the
<code>prob_fun</code> argument in our approach is comparatively small,
but it might still be a concern for some users. We hope that the many
provided examples and explanations in both this article and the
extensive documentation and multiple vignettes of the package will help
users overcome this issue.</p>
<p>To keep this article at a reasonable length, it was necessary to omit
some implemented features of the <code>simDAG</code> package. One of
these features is its capability to generate data for complex
multi-level DGPs. By internally using code from the <code>simr</code>
package <span class="citation">(Green and MacLeod 2016)</span>, it
allows users to add arbitrarily complex random effects and random slopes
to nodes of type <code>&quot;gaussian&quot;</code>, <code>&quot;binomial&quot;</code> and
<code>&quot;poisson&quot;</code>. This can be done by directly adding the standard
mixed model <code>R</code> syntax to the <code>formula</code> interface.
Additionally, while the main focus of the package is on generating data
from a user-defined DGP, the package offers limited support for
generating data that mimics already existing data through the
<code>dag_from_data()</code> function. This function only requires the
user to specify the causal dependencies assumed to be present in the
data and the type of each node and then directly extracts coefficients
and intercepts from the available data by fitting various models to it.
The returned DAG is then fully specified and can be used directly in a
standard <code>sim_from_dag()</code> call to obtain data similar to the
one supplied. Note that this function does not directly support all
available node types. If the main goal of the user is to generate such
synthetic mimicked datasets, using packages such as <code>simPop</code>
<span class="citation">(Templ et al. 2017)</span> might be
preferable.</p>
<p>Finally, we would like to note that the package is still under active
development. We are currently working on multiple new features to make
the package even more versatile for users. For example, future versions
of the package are planned to support the definition of interventions on
the DAG, much like the <code>simcausal</code> package <span class="citation">(Sofrygin, van der Laan, and Neugebauer 2017)</span>,
which would make it even easier to generate data for causal inference
based simulations, without having to re-define the DAG multiple times.
We also plan to extend the internal library of available node types, by
for example including node functions to simulate competing events data
without the use of discrete-time simulation <span class="citation">(Moriña and Navarro 2017; Haller and Ulm
2014)</span>.</p>
</div>
<div id="computational-details" class="section level1">
<h1>Computational details</h1>
<p>The results in this paper were obtained using <code>R</code> 4.5.0
with the <code>data.table</code> 1.17.0 package, the
<code>survival</code> 3.8.3 package, the <code>igraph</code> 2.1.4
package, the <code>ggplot2</code> 3.5.2 package and the
<code>simDAG</code> 0.4.1 package. <code>R</code> itself and all
packages used are available from the Comprehensive <code>R</code>
Archive Network (CRAN) at <a href="https://CRAN.R-project.org/" class="uri">https://CRAN.R-project.org/</a>.</p>
</div>
<div id="acknowledgments" class="section level1">
<h1>Acknowledgments</h1>
<p>We would like to thank Katharina Meiszl for her valuable input and
for contributing some unit tests and input checks to the proposed
package. We would also like to thank the anonymous reviewers, whose
feedback and suggestions greatly improved the manuscript and the package
itself.</p>
</div>
<div id="appendix-a-further-features-of-discrete-time-simulation" class="section level1">
<h1>Appendix A: Further Features of Discrete-Time Simulation</h1>
<p>As mentioned in the main text, there are a lot of possible features
that could be included in the DGP using the discrete-time simulation
approach, which are not shown in the main text. Below we will give some
simple examples on how to use the discrete-time simulation approach
implemented in the <code>simDAG</code> package to generate artificial
data with some of these useful features. For most of these examples, the
first DGP shown in the Covid example Section will be extended.</p>
<div id="time-dependent-base-probabilities" class="section level2">
<h2>Time-Dependent Base Probabilities</h2>
<p>To make <span class="math inline">\(P_{Y0}\)</span> time-dependent,
the <code>sim_time</code> argument may be used to change the definition
of the function that generates the myocarditis probabilities. The
following code gives an example for this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A, sim_time) {</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  P_0 <span class="ot">&lt;-</span> P_0 <span class="sc">+</span> <span class="fl">0.001</span><span class="sc">*</span>sim_time</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>}</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>)</span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span id="cb23-17"><a href="#cb23-17" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    13  FALSE  FALSE</span></span>
<span id="cb23-18"><a href="#cb23-18" tabindex="-1"></a><span class="co">#&gt; 2:     1    14    17   TRUE  FALSE</span></span>
<span id="cb23-19"><a href="#cb23-19" tabindex="-1"></a><span class="co">#&gt; 3:     1    18    18   TRUE   TRUE</span></span>
<span id="cb23-20"><a href="#cb23-20" tabindex="-1"></a><span class="co">#&gt; 4:     1    19    24   TRUE  FALSE</span></span>
<span id="cb23-21"><a href="#cb23-21" tabindex="-1"></a><span class="co">#&gt; 5:     1    25    25   TRUE   TRUE</span></span>
<span id="cb23-22"><a href="#cb23-22" tabindex="-1"></a><span class="co">#&gt; 6:     1    26    33   TRUE  FALSE</span></span></code></pre></div>
<p>In this example, the base probability of myocarditis grows by 0.001
with each passing day, but the relative risk of infection given a
vaccination stays constant. More complex time-dependencies may of course
be implemented as well. The same procedure could also be used to make
the vaccination probabilities time-dependent as well.</p>
</div>
<div id="time-dependent-effects" class="section level2">
<h2>Time-Dependent Effects</h2>
<p>In some scenarios it may also be required to make the effect itself
vary over time. Here, we could make the size of the relative risk of
developing a myocarditis given a recent Covid-19 vaccination dependent
on the calender time, again by using the <code>sim_time</code> argument
in the respective <code>prob_fun</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A, sim_time) {</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>  RR_A <span class="ot">&lt;-</span> RR_A <span class="sc">+</span> <span class="fl">0.01</span><span class="sc">*</span>sim_time</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>}</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>)</span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb24-14"><a href="#cb24-14" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb24-15"><a href="#cb24-15" tabindex="-1"></a><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span id="cb24-16"><a href="#cb24-16" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span id="cb24-17"><a href="#cb24-17" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    16  FALSE  FALSE</span></span>
<span id="cb24-18"><a href="#cb24-18" tabindex="-1"></a><span class="co">#&gt; 2:     1    17    36   TRUE  FALSE</span></span>
<span id="cb24-19"><a href="#cb24-19" tabindex="-1"></a><span class="co">#&gt; 3:     1    37   200  FALSE  FALSE</span></span>
<span id="cb24-20"><a href="#cb24-20" tabindex="-1"></a><span class="co">#&gt; 4:     2     1    21  FALSE  FALSE</span></span>
<span id="cb24-21"><a href="#cb24-21" tabindex="-1"></a><span class="co">#&gt; 5:     2    22    22  FALSE   TRUE</span></span>
<span id="cb24-22"><a href="#cb24-22" tabindex="-1"></a><span class="co">#&gt; 6:     2    23    58  FALSE  FALSE</span></span></code></pre></div>
<p>Here, the relative risk increases by 0.01 for each passing day,
meaning that the risk of a myocarditis given a recent vaccination
increases over time.</p>
</div>
<div id="non-linear-effects" class="section level2">
<h2>Non-Linear Effects</h2>
<p>In all previous examples, it was assumed that the effect of the
vaccination on the probability of developing a myocarditis follows a
step-function. The risk was instantly elevated by a constant factor
(<span class="math inline">\(RR_A\)</span>) after vaccination, which
lasts for a specified amount of time and then instantly drops back to
the baseline risk. Any other kind of relationship may also be simulated,
by again changing the <code>prob_myoc()</code> function accordingly. The
following code may be used:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A) {</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  RR_A <span class="ot">&lt;-</span> RR_A <span class="sc">-</span> <span class="fl">0.1</span><span class="sc">*</span>data<span class="sc">$</span>A_time_since_last</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>}</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>,</span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>          <span class="at">time_since_last=</span><span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>, <span class="st">&quot;A_time_since_last&quot;</span>),</span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>          <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>)</span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a><span class="co">#&gt;      .id start  stop      A      Y</span></span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a><span class="co">#&gt; 1:     1     1     6  FALSE  FALSE</span></span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a><span class="co">#&gt; 2:     1     7    26   TRUE  FALSE</span></span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a><span class="co">#&gt; 3:     1    27    29  FALSE  FALSE</span></span>
<span id="cb25-22"><a href="#cb25-22" tabindex="-1"></a><span class="co">#&gt; 4:     1    30    30  FALSE   TRUE</span></span>
<span id="cb25-23"><a href="#cb25-23" tabindex="-1"></a><span class="co">#&gt; 5:     1    31   200  FALSE  FALSE</span></span>
<span id="cb25-24"><a href="#cb25-24" tabindex="-1"></a><span class="co">#&gt; 6:     2     1    43  FALSE  FALSE</span></span></code></pre></div>
<p>In this code, <span class="math inline">\(RR_A\)</span> decreases
with each day after a person is vaccinated. In contrast to the previous
example, this happens on a person-specific time-scale and not on a total
calender time level. To do this properly, we set the
<code>time_since_last</code> argument inside the <code>node_td()</code>
call of the vaccination definition to <code>TRUE</code>. This argument
is supported when using nodes of type <code>&quot;time_to_event&quot;</code>. It
adds another column to the dataset which includes the time since the
last vaccination was performed for each individual. This column is then
also added in the <code>parents</code> vector, so that we can use it in
<code>prob_myoc()</code> function. Here we simply substract 0.1 from
<span class="math inline">\(RR_A\)</span> for each day after
vaccination. This essentially means that on the day of vaccination
itself, the relative risk will be 3.24 as specified in the
<code>DAG</code>. On the first day after the vaccination, however, the
relative risk will only be 3.14 and so forth. In other words, the extent
of the adverse effect of the vaccination decreases over time linearly.
Again, more complex functions may also be used to model this type of
non-linear effects.</p>
</div>
<div id="multiple-interrelated-binary-time-dependent-variables" class="section level2">
<h2>Multiple Interrelated Binary Time-Dependent Variables</h2>
<p>Another possibility to extent the DGP would be to add more
<code>&quot;time_to_event&quot;</code> variables. For example, we may want to
additionally consider the effect of a Covid-19 infection itself, denoted
by <span class="math inline">\(C_t\)</span> here. For simplicity we will
assume that Covid-19 has a constant probability of occurrence over time
which is the same for all individuals.In this example we will assume
that the vaccination reduces the risk of getting a Covid-19 infection to
0 for <span class="math inline">\(d_{immune}\)</span> days after the
vaccination was performed. We may use the following structural equation
to describe this variable:</p>
<p><span class="math display">\[
    C_t \sim Bernoulli(P_{C}(t)),
\]</span></p>
<p>with:</p>
<p><span class="math display">\[
    P_{C}(t) =
    \begin{cases}
        0, &amp; \text{if } t \in  \left[T_{A}(t), T_{A}(t) +
d_{immune}\right] \\
        P_{C0}, &amp; \text{otherwise}
    \end{cases},
\]</span></p>
<p>where <span class="math inline">\(P_{C0}\)</span> is the baseline
probability of experiencing a Covid-19 infection and <span class="math inline">\(T_A(t)\)</span> is still defined to be the time of
the last Covid-19 vaccination as before. In addition to this, we will
also change the definition of the myocarditis node (<span class="math inline">\(Y_t\)</span>). Instead of being only dependent on
<span class="math inline">\(A_t\)</span>, the Covid-19 Infection should
now also raise the probability of developing a myocarditis by a constant
factor <span class="math inline">\(RR_C\)</span> in the <span class="math inline">\(d_{C.risk}\)</span> days after the Covid-19
infection. The structural equation can then be changed to be:</p>
<p><span class="math display">\[
    Y_t \sim Bernoulli(P_{Y}(t)),
\]</span></p>
<p>with:</p>
<p><span class="math display">\[
    P_{Y}(t) =
    \begin{cases}
        P_{Y0} \cdot RR_{A} \cdot RR_{C}, &amp; \text{if } t
\in  \left[T_{A}(t), T_{A}(t) + d_{A.risk}\right] \text{ and } t
\in  \left[T_{A}(t), T_{A}(t) + d_{C.risk}\right] \\
        P_{Y0} \cdot RR_{C}, &amp; \text{if } t \in  \left[T_{A}(t),
T_{A}(t) + d_{C.risk}\right] \\
        P_{Y0} \cdot RR_{A}, &amp; \text{if } t \in  \left[T_{A}(t),
T_{A}(t) + d_{A.risk}\right] \\
        P_{Y0}, &amp; \text{otherwise}
    \end{cases},
\]</span></p>
<p>where <span class="math inline">\(d_{A.risk}\)</span> is the duration
after vaccination in which the risk of developing a myocarditis is
elevated by <span class="math inline">\(RR_A\)</span>. The structural
equation for <span class="math inline">\(A\)</span> are the same as
defined in previous Equations. The following code may be used to
generate data from this DGP:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A, RR_C) {</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>  P_0 <span class="sc">*</span> RR_A<span class="sc">^</span>(data<span class="sc">$</span>A_event) <span class="sc">*</span> RR_C<span class="sc">^</span>(data<span class="sc">$</span>C_event)</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>}</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>prob_covid <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, d_immune) {</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_time_since_last <span class="sc">&lt;</span> d_immune, <span class="dv">0</span>, P_0, <span class="at">na=</span>P_0)</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>}</span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>,</span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a>          <span class="at">time_since_last=</span><span class="cn">TRUE</span>) <span class="sc">+</span></span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;C&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_covid,</span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_time_since_last&quot;</span>), <span class="at">event_duration=</span><span class="dv">14</span>,</span>
<span id="cb26-15"><a href="#cb26-15" tabindex="-1"></a>          <span class="at">P_0=</span><span class="fl">0.01</span>, <span class="at">d_immune=</span><span class="dv">120</span>) <span class="sc">+</span></span>
<span id="cb26-16"><a href="#cb26-16" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb26-17"><a href="#cb26-17" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>, <span class="st">&quot;A_time_since_last&quot;</span>, <span class="st">&quot;C_event&quot;</span>),</span>
<span id="cb26-18"><a href="#cb26-18" tabindex="-1"></a>          <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>, <span class="at">RR_C=</span><span class="fl">2.5</span>)</span>
<span id="cb26-19"><a href="#cb26-19" tabindex="-1"></a></span>
<span id="cb26-20"><a href="#cb26-20" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>)</span>
<span id="cb26-21"><a href="#cb26-21" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb26-22"><a href="#cb26-22" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb26-23"><a href="#cb26-23" tabindex="-1"></a><span class="co">#&gt;      .id start  stop      A      C      Y</span></span>
<span id="cb26-24"><a href="#cb26-24" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span id="cb26-25"><a href="#cb26-25" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    46  FALSE  FALSE  FALSE</span></span>
<span id="cb26-26"><a href="#cb26-26" tabindex="-1"></a><span class="co">#&gt; 2:     1    47    47  FALSE  FALSE   TRUE</span></span>
<span id="cb26-27"><a href="#cb26-27" tabindex="-1"></a><span class="co">#&gt; 3:     1    48    50  FALSE  FALSE  FALSE</span></span>
<span id="cb26-28"><a href="#cb26-28" tabindex="-1"></a><span class="co">#&gt; 4:     1    51    51  FALSE  FALSE   TRUE</span></span>
<span id="cb26-29"><a href="#cb26-29" tabindex="-1"></a><span class="co">#&gt; 5:     1    52    58  FALSE  FALSE  FALSE</span></span>
<span id="cb26-30"><a href="#cb26-30" tabindex="-1"></a><span class="co">#&gt; 6:     1    59    72  FALSE   TRUE  FALSE</span></span></code></pre></div>
<p>In this code we first re-define the <code>prob_myoc()</code> function
to include the effect of the Covid-19 infection. This utilizes a small
computational trick, relying on the fact that any number to the power of
0 is 1 and any number to the power of 1 is itself. Since
<code>TRUE</code> is treated as a 1 and <code>FALSE</code> is
interpreted as a 0 in R, we can simply take the relative risks to the
power of their current event indicator to only multiply the baseline
risk with the respective relative risks if they are currently in the
risk durations. Next, we define a new function called
<code>prob_covid()</code> to include the immunity duration, again using
the <code>time_since_last</code> functionality. By finally adding
another <code>node_td()</code> call to the <code>DAG</code> object, we
were able to specify the DGP in the desired way.</p>
</div>
<div id="using-baseline-covariates" class="section level2">
<h2>Using Baseline Covariates</h2>
<p>Previously, only time-dependent variable were included in the DGP. By
adding calls to the simple <code>node()</code> function to the
<code>DAG</code> object it is, however, also possible to additionally
include time-independent variables as well. Suppose that we want the
baseline probability <span class="math inline">\(P_{A0}\)</span> of the
vaccination to vary by biological sex in the first DGP described in the
Covid example Section. We could do this using the following code:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A) {</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>}</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>prob_vacc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0) {</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>Sex, P_0<span class="sc">*</span><span class="dv">2</span>, P_0)</span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>}</span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;Sex&quot;</span>, <span class="at">type=</span><span class="st">&quot;rbernoulli&quot;</span>, <span class="at">p=</span><span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb27-11"><a href="#cb27-11" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb27-12"><a href="#cb27-12" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="dv">20</span>, <span class="at">immunity_duration=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb27-13"><a href="#cb27-13" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb27-14"><a href="#cb27-14" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span>
<span id="cb27-15"><a href="#cb27-15" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>)</span>
<span id="cb27-17"><a href="#cb27-17" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb27-18"><a href="#cb27-18" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb27-19"><a href="#cb27-19" tabindex="-1"></a><span class="co">#&gt;      .id start  stop      A      Y    Sex</span></span>
<span id="cb27-20"><a href="#cb27-20" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt; &lt;lgcl&gt; &lt;lgcl&gt;</span></span>
<span id="cb27-21"><a href="#cb27-21" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    48  FALSE  FALSE  FALSE</span></span>
<span id="cb27-22"><a href="#cb27-22" tabindex="-1"></a><span class="co">#&gt; 2:     1    49    49  FALSE   TRUE  FALSE</span></span>
<span id="cb27-23"><a href="#cb27-23" tabindex="-1"></a><span class="co">#&gt; 3:     1    50    58  FALSE  FALSE  FALSE</span></span>
<span id="cb27-24"><a href="#cb27-24" tabindex="-1"></a><span class="co">#&gt; 4:     1    59    59  FALSE   TRUE  FALSE</span></span>
<span id="cb27-25"><a href="#cb27-25" tabindex="-1"></a><span class="co">#&gt; 5:     1    60   200  FALSE  FALSE  FALSE</span></span>
<span id="cb27-26"><a href="#cb27-26" tabindex="-1"></a><span class="co">#&gt; 6:     2     1     4  FALSE  FALSE   TRUE</span></span></code></pre></div>
<p>Here, everything is kept the same as in the original example, with
the small change that we now add a call to <code>node()</code> before
adding the time-dependent variables to define the <code>Sex</code> node
using a simple Bernoulli distribution. Additionally, we now had to
define a function that appropriately generates the probabilities of
vaccination per <code>Sex</code>. This was done by simply increasing
<span class="math inline">\(P_0\)</span> by a factor of 2 whenever the
value of <code>Sex</code> is <code>TRUE</code> (which might stand for
males or females). It would also be possible to add child
time-independent child nodes as well, but this is left as an exercise to
the interested reader.</p>
</div>
<div id="using-categorical-time-dependent-variables" class="section level2">
<h2>Using Categorical Time-Dependent Variables</h2>
<p>The previous examples all included only binary time-dependent
variables. For some applications it may be necessary to used categorical
time-dependent variables. For example, instead of generating the
vaccination status as binary, we may want to model it as a categorical
variable with multiple levels, indicating which kind of vaccine the
person received (if any). This may be done using the
<code>&quot;competing_events&quot;</code> node <code>type</code>. Below is a
simple example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>prob_myoc <span class="ot">&lt;-</span> <span class="cf">function</span>(data, P_0, RR_A) {</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>A_event <span class="sc">&gt;</span> <span class="dv">0</span>, P_0<span class="sc">*</span>RR_A, P_0)</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>}</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>prob_vacc <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(data)</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>  p_mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="fl">0.99</span>, n), <span class="fu">rep</span>(<span class="fl">0.0005</span>, n),</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>                    <span class="fu">rep</span>(<span class="fl">0.0005</span>, n)),</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>                  <span class="at">byrow=</span><span class="cn">FALSE</span>, <span class="at">ncol=</span><span class="dv">3</span>)</span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>  <span class="fu">return</span>(p_mat)</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>}</span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;A&quot;</span>, <span class="at">type=</span><span class="st">&quot;competing_events&quot;</span>, <span class="at">prob_fun=</span>prob_vacc,</span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">20</span>), <span class="at">immunity_duration=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;Y&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_myoc,</span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>          <span class="at">parents=</span><span class="fu">c</span>(<span class="st">&quot;A_event&quot;</span>), <span class="at">P_0=</span><span class="fl">0.005</span>, <span class="at">RR_A=</span><span class="fl">3.24</span>)</span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>,</span>
<span id="cb28-20"><a href="#cb28-20" tabindex="-1"></a>                         <span class="at">save_states=</span><span class="st">&quot;all&quot;</span>)</span>
<span id="cb28-21"><a href="#cb28-21" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb28-22"><a href="#cb28-22" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb28-23"><a href="#cb28-23" tabindex="-1"></a><span class="co">#&gt;      .id start  stop     A      Y</span></span>
<span id="cb28-24"><a href="#cb28-24" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;num&gt; &lt;lgcl&gt;</span></span>
<span id="cb28-25"><a href="#cb28-25" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    23     0  FALSE</span></span>
<span id="cb28-26"><a href="#cb28-26" tabindex="-1"></a><span class="co">#&gt; 2:     1    24    24     0   TRUE</span></span>
<span id="cb28-27"><a href="#cb28-27" tabindex="-1"></a><span class="co">#&gt; 3:     1    25    53     0  FALSE</span></span>
<span id="cb28-28"><a href="#cb28-28" tabindex="-1"></a><span class="co">#&gt; 4:     1    54    73     1  FALSE</span></span>
<span id="cb28-29"><a href="#cb28-29" tabindex="-1"></a><span class="co">#&gt; 5:     1    74   159     0  FALSE</span></span>
<span id="cb28-30"><a href="#cb28-30" tabindex="-1"></a><span class="co">#&gt; 6:     1   160   160     0   TRUE</span></span></code></pre></div>
<p>The <code>&quot;competing_events&quot;</code> node <code>type</code> works in
much the same way as the <code>&quot;time_to_event&quot;</code> node type, with
the main difference being that instead of using Bernoulli trials it
relies on multinomial trials, which are equivalent to drawing a simple
random sample with unequal probabilities for each element. Instead of
supplying a single probability of success per person and per point in
time, the <code>prob_fun</code> supplied to a
<code>&quot;competing_events&quot;</code> node is therefore expected to provide a
vector of probabilities. In the example above, we simply define the
probabilities to be the same for everyone regardless of the simulated
time. The first category represents “no vaccination” while the next two
categories specify vaccinations with vaccines of different kinds. Note
that in this code, the <code>prob_myoc()</code> function only checks
whether there was any vaccination, so it does not really make a
difference whether one uses a <code>&quot;competing_events&quot;</code> or
<code>&quot;time_to_event&quot;</code> node here.</p>
<p>To get more useful person specific multinomial probabilities, the
<code>node_multinomial()</code> function may be useful. Because the
underlying code for multinomial trials is a bit more complex than the
code for simple Bernoulli trials, using this type of node may lead to an
increased runtime. The node type is usually most useful when the goal is
to generate artificial time-to-event data with mutually exclusive types
of events, also known as competing events or competing risks data. Also
note that in the example we had to set the <code>save_states</code>
argument of the <code>sim_discrete_time()</code> function to
<code>&quot;all&quot;</code>. This is required when the goal is to transform the
data into the start-stop format later, because the DGP does not consist
solely of time-dependent nodes of type <code>&quot;time_to_event&quot;</code>.</p>
</div>
<div id="using-continuous-time-dependent-variables" class="section level2">
<h2>Using Continuous Time-Dependent Variables</h2>
<p>It is also possible to use continuous variables as time-dependent
variables in the proposed package. The following code gives a very
simple example:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>  <span class="fu">node</span>(<span class="st">&quot;calories&quot;</span>, <span class="at">type=</span><span class="st">&quot;rnorm&quot;</span>, <span class="at">mean=</span><span class="dv">2500</span>, <span class="at">sd=</span><span class="dv">150</span>) <span class="sc">+</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;calories&quot;</span>, <span class="at">type=</span><span class="st">&quot;gaussian&quot;</span>,</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>          <span class="at">formula=</span> <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> calories<span class="sc">*</span><span class="fl">1.1</span>, <span class="at">error=</span><span class="dv">1</span>)</span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>,</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>                         <span class="at">save_states=</span><span class="st">&quot;all&quot;</span>)</span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;long&quot;</span>)</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a><span class="co">#&gt; Key: &lt;.id, .time&gt;</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a><span class="co">#&gt;      .id .time calories</span></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt;    &lt;num&gt;</span></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a><span class="co">#&gt; 1:     1     1 2837.652</span></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a><span class="co">#&gt; 2:     1     2 3123.649</span></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a><span class="co">#&gt; 3:     1     3 3436.496</span></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a><span class="co">#&gt; 4:     1     4 3782.254</span></span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a><span class="co">#&gt; 5:     1     5 4160.574</span></span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a><span class="co">#&gt; 6:     1     6 4577.265</span></span></code></pre></div>
<p>In this example, we first generate a normally distributed root node
called <code>calories</code> using a standard <code>node()</code> call.
This represents the value of the variable at <span class="math inline">\(t = 0\)</span>. If we did not specify this
variable, the code would return an error message at <span class="math inline">\(t = 1\)</span>, because there would be no value of
<code>calories</code> to use in the subsequently defined regression
model. Next, a call to <code>node_td()</code> is added to the
<code>DAG</code> object to specify how this variable changes with each
step in time. We use a simple linear regression model, where the only
independent variable is the last value of the variable itself. In the
subsequent simulation we again set <code>save_states=&quot;all&quot;</code> to
specify that the data at all points in time should be saved. This is
necessary here both because the <code>DAG</code> consists of
time-dependent nodes that are not of type <code>&quot;time_to_event&quot;</code>,
and because the variable changes at every point in time for every
individual. Because of the nature of the data, it would also not make
sense to transform the data into the start-stop format. Instead, the
long format is choosen here.</p>
</div>
<div id="ordered-events" class="section level2">
<h2>Ordered Events</h2>
<p>The following code gives an example on how events could be simulated
so that a specific order of events is always respected:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>prob_bachelors <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>highschool_event, <span class="fl">0.01</span>, <span class="dv">0</span>)</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>}</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>prob_masters <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>  <span class="fu">fifelse</span>(data<span class="sc">$</span>bachelors_event, <span class="fl">0.01</span>, <span class="dv">0</span>)</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>}</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a>dag <span class="ot">&lt;-</span> <span class="fu">empty_dag</span>() <span class="sc">+</span></span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;highschool&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span><span class="fl">0.01</span>,</span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="cn">Inf</span>) <span class="sc">+</span></span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;bachelors&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_bachelors,</span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="cn">Inf</span>, <span class="at">parents=</span><span class="st">&quot;highschool_event&quot;</span>) <span class="sc">+</span></span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a>  <span class="fu">node_td</span>(<span class="st">&quot;masters&quot;</span>, <span class="at">type=</span><span class="st">&quot;time_to_event&quot;</span>, <span class="at">prob_fun=</span>prob_masters,</span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a>          <span class="at">event_duration=</span><span class="cn">Inf</span>, <span class="at">parents=</span><span class="st">&quot;bachelors_event&quot;</span>)</span>
<span id="cb30-16"><a href="#cb30-16" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">sim_discrete_time</span>(dag, <span class="at">n_sim=</span><span class="dv">100</span>, <span class="at">max_t=</span><span class="dv">200</span>)</span>
<span id="cb30-18"><a href="#cb30-18" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">sim2data</span>(sim, <span class="at">to=</span><span class="st">&quot;start_stop&quot;</span>)</span>
<span id="cb30-19"><a href="#cb30-19" tabindex="-1"></a><span class="fu">head</span>(data)</span>
<span id="cb30-20"><a href="#cb30-20" tabindex="-1"></a><span class="co">#&gt;      .id start  stop highschool bachelors masters</span></span>
<span id="cb30-21"><a href="#cb30-21" tabindex="-1"></a><span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;num&gt;     &lt;lgcl&gt;    &lt;lgcl&gt;  &lt;lgcl&gt;</span></span>
<span id="cb30-22"><a href="#cb30-22" tabindex="-1"></a><span class="co">#&gt; 1:     1     1    75      FALSE     FALSE   FALSE</span></span>
<span id="cb30-23"><a href="#cb30-23" tabindex="-1"></a><span class="co">#&gt; 2:     1    76   200       TRUE     FALSE   FALSE</span></span>
<span id="cb30-24"><a href="#cb30-24" tabindex="-1"></a><span class="co">#&gt; 3:     2     1     4      FALSE     FALSE   FALSE</span></span>
<span id="cb30-25"><a href="#cb30-25" tabindex="-1"></a><span class="co">#&gt; 4:     2     5   178       TRUE     FALSE   FALSE</span></span>
<span id="cb30-26"><a href="#cb30-26" tabindex="-1"></a><span class="co">#&gt; 5:     2   179   200       TRUE      TRUE   FALSE</span></span>
<span id="cb30-27"><a href="#cb30-27" tabindex="-1"></a><span class="co">#&gt; 6:     3     1   116      FALSE     FALSE   FALSE</span></span></code></pre></div>
<p>In this specification, we try to simulate the educational status of a
person over time. We assume that individuals can only obtain a bachelors
degree once they have finished high school and that they can only
receive a masters degree once they finished the bachelors degree. To
keep this order of events in tact, we can split the variable into its
three constituent parts. First, the indicator whether someone graduated
<code>highschool</code> is simulated using simple Bernoulli trials as
implemented in the <code>&quot;time_to_event&quot;</code> node type. By setting
<code>event_duration=Inf</code>, we ensure that no one ever “looses”
their degree. Only afterwards do we generate whether the same person
also received a <code>bachelors</code> degree. By using a standard
<code>fifelse()</code> call, we can easily specify that the probability
of obtaining a <code>bachelors</code> degree is 0 for individuals
without a <code>highschool</code> degree. Subsequently, we do the same
for the <code>masters</code> node.</p>
<p>Again, this simulation could be made much more realistic. For
example, in the example used here there is no limitations on how close
the different graduations can be to each other. An individual might
receive all three degrees in the same time unit. This could be changed
by using the <code>sim_time</code> argument in the definition of the
probability functions, as discussed earlier.</p>
</div>
</div>
<div id="literature" class="section level1 unnumbered">
<h1 class="unnumbered">Literature</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Alfons2010" class="csl-entry">
Alfons, Andreas, Matthias Templ, and Peter Filzmoser. 2010. <span>“An
Object-Oriented Framework for Statistical Simulation: The r Package
simFrame.”</span> <em>Journal of Statistical Software</em> 37 (3): 1–36.
<a href="https://doi.org/10.18637/jss.v037.i03">https://doi.org/10.18637/jss.v037.i03</a>.
</div>
<div id="ref-Andrews2024" class="csl-entry">
Andrews, Bryan, and Erich Kummerfeld. 2024. <span>“Better Simulations
for Validating Causal Discovery with the DAG-Adaptation of the Onion
Method.”</span> arXiv:2405.13100v1.
</div>
<div id="ref-Arnold2011" class="csl-entry">
Arnold, Benjamin F., Daniel R. Hogan, John M. Colford Jr., and Alan E.
Hubbard. 2011. <span>“Simulation Methods to Estimate Design Power: An
Overview for Applied Research.”</span> <em>BMC Medical Research
Methodology</em> 11 (94): 1–10. <a href="https://doi.org/10.1186/1471-2288-11-94">https://doi.org/10.1186/1471-2288-11-94</a>.
</div>
<div id="ref-Asparouhov2020" class="csl-entry">
Asparouhov, Tihomir, and Bengt Muthén. 2020. <span>“Comparison of Models
for the Analysis of Intensive Longitudinal Data.”</span> <em>Structural
Equation Modeling: A Multidisciplinary Journal</em> 27 (2): 275–97. <a href="https://doi.org/10.1080/10705511.2019.1626733">https://doi.org/10.1080/10705511.2019.1626733</a>.
</div>
<div id="ref-Austin2012" class="csl-entry">
Austin, Peter C. 2012. <span>“Generating Survival Times to Simulate Cox
Proportional Hazards Models with Time-Varying Covariates.”</span>
<em>Statistics in Medicine</em> 31 (29): 3946–58. <a href="https://doi.org/10.1002/sim.5452">https://doi.org/10.1002/sim.5452</a>.
</div>
<div id="ref-Banks2014" class="csl-entry">
Banks, Jerry, John S. Carson II, Barry L. Nelson, and David M. Nicol.
2014. <em>Discrete-Event System Simulation</em>. Vol. 5. Edinburgh Gate:
Pearson Education Limited.
</div>
<div id="ref-Barrett2024" class="csl-entry">
Barrett, Tyson, Matt Dowle, Arun Srinivasan, Jan Gorecki, Michael
Chirico, and Toby Hocking. 2024. <em>Data.table: Extension of
‘Data.frame‘</em>. <a href="https://CRAN.R-project.org/package=data.table">https://CRAN.R-project.org/package=data.table</a>.
</div>
<div id="ref-Bender2005" class="csl-entry">
Bender, Ralf, Thomas Augustin, and Maria Blettner. 2005.
<span>“Generating Survival Times to Simulate Cox Proportional Hazards
Models.”</span> <em>Statistics in Medicine</em> 24 (11): 1713–23. <a href="https://doi.org/10.1002/sim.2059">https://doi.org/10.1002/sim.2059</a>.
</div>
<div id="ref-Brilleman2021" class="csl-entry">
Brilleman, Samuel L., Rory Wolfe, Margarita Moreno-Betancur, and Michael
J. Crowther. 2021. <span>“Simulating Survival Data Using the Simsurv r
Package.”</span> <em>Journal of Statistical Software</em> 97 (3). <a href="https://doi.org/10.18637/jss.v097.i03">https://doi.org/10.18637/jss.v097.i03</a>.
</div>
<div id="ref-Byeon2023" class="csl-entry">
Byeon, Sangmin, and Woojoo Lee. 2023. <span>“Directed Acyclic Graphs for
Clinical Research: A Tutorial.”</span> <em>Journal of Minimally Invasive
Surgery</em> 26 (3): 97–107. <a href="https://doi.org/10.7602/jmis.2023.26.3.97">https://doi.org/10.7602/jmis.2023.26.3.97</a>.
</div>
<div id="ref-Carsey2014" class="csl-entry">
Carsey, Thomas M., and Jeffrey J. Harden. 2014. <em>Monte Carlo
Simulation and Resampling Methods for Social Science</em>. Thousand
Oaks: SAGE Publications.
</div>
<div id="ref-Cheng2016" class="csl-entry">
Cheng, Adam, David Kessler, Ralph Mackinnon, Todd P. Chang, Vinay M.
Nadkarni, Elizabeth A. Hunt, Jordan Duval-Arnould, et al. 2016.
<span>“Reporting Guidelines for Health Care Simulation Research:
Extensions to the CONSORT and STROBE Statements.”</span> <em>Advances in
Simulation</em> 1 (25): 1–13. <a href="https://doi.org/10.1186/s41077-016-0025-y">https://doi.org/10.1186/s41077-016-0025-y</a>.
</div>
<div id="ref-Chiou2023" class="csl-entry">
Chiou, Sy Han, Gongjun Xu, and Jun Yan Chiung-Yu Huang. 2023.
<span>“Regression Modeling for Recurrent Events Possibly with an
Informative Terminal Event Using r Package reReg.”</span> <em>Journal of
Statistical Software</em> 105 (5): 1–34. <a href="https://doi.org/10.18637/jss.v105.i05">https://doi.org/10.18637/jss.v105.i05</a>.
</div>
<div id="ref-Csardi2024" class="csl-entry">
Csárdi, Gábor, Tamás Nepusz, Vincent Traag, Szabolcs Horvát, Fabio
Zanini, Daniel Noom, and Kirill Müller. 2024. <em>Igraph: Network
Analysis and Visualization in r</em>. <a href="https://doi.org/10.5281/zenodo.7682609">https://doi.org/10.5281/zenodo.7682609</a>.
</div>
<div id="ref-Demarqui2024" class="csl-entry">
Demarqui, Fábio N. 2024. <span>“Survival Data Simulation with the r
Package Rsurv.”</span> arXiv:2406.01750v1.
</div>
<div id="ref-Denz2023" class="csl-entry">
Denz, Robin, Renate Klaaßen-Mielke, and Nina Timmesfeld. 2023. <span>“A
Comparison of Different Methods to Adjust Survival Curves for
Confounders.”</span> <em>Statistics in Medicine</em> 42 (10): 1461–79.
<a href="https://doi.org/10.1002/sim.9681">https://doi.org/10.1002/sim.9681</a>.
</div>
<div id="ref-Denz2023a" class="csl-entry">
Denz, Robin, Katharina Meiszl, Peter Ihle, Doris Oberle, Ursula
Drechsel-Bäuerle, Katrin Scholz, Ingo Meyer, and Nina Timmesfeld. 2025.
<span>“Impact of Record-Linkage Errors in Covid-19 Vaccine-Safety
Analyses Using German Health-Care Data: A Simulation Study.”</span>
<em>Communications in Statistics: Simulation and Computation</em>
InPrint. <a href="https://doi.org/10.1080/03610918.2025.2488942">https://doi.org/10.1080/03610918.2025.2488942</a>.
</div>
<div id="ref-Denz2025" class="csl-entry">
Denz, Robin, and Nina Timmesfeld. 2025. <span>“Simulating Complex
Crossectional and Longitudinal Data Using the simDAG r Package.”</span>
<em>arXiv Preprint</em>. <a href="https://doi.org/10.48550/arXiv.2506.01498">https://doi.org/10.48550/arXiv.2506.01498</a>.
</div>
<div id="ref-Fox2022" class="csl-entry">
Fox, Matthew P., Roch Nianogo, Jacqueline E. Rudolph, and Chanelle J.
Howe. 2022. <span>“Illustrating How to Simulate Data from Directed
Acyclic Graphs to Understand Epidemiologic Concepts.”</span>
<em>American Journal of Epidemiology</em> 191 (7): 1300–1306. <a href="https://doi.org/10.1093/aje/kwac041">https://doi.org/10.1093/aje/kwac041</a>.
</div>
<div id="ref-Goldfeld2020" class="csl-entry">
Goldfeld, Keith, and Jacob Wujciak-Jens. 2020. <span>“Simstudy:
Illuminating Research Methods Through Data Generation.”</span> <em>The
Journal of Open Source Software</em> 5 (54): 1–4. <a href="https://doi.org/10.21105/joss.02763">https://doi.org/10.21105/joss.02763</a>.
</div>
<div id="ref-Green2016" class="csl-entry">
Green, Peter, and Catriona J. MacLeod. 2016. <span>“Simr: An r Package
for Power Analysis of Generalized Linear Mixed Models by
Simulation.”</span> <em>Methods in Ecology and Evolution</em> 7 (4):
493–98. <a href="https://doi.org/10.1111/2041-210X.12504">https://doi.org/10.1111/2041-210X.12504</a>.
</div>
<div id="ref-Gruber2015" class="csl-entry">
Gruber, Susan, Roger W. Logan, Inmaculada Jarrín, Susana Monge, and
Miguel A. Hernán. 2015. <span>“Ensemble Learning of Inverse Probability
Weights for Marginal Structural Modeling in Large Observational
Datasets.”</span> <em>Statistics in Medicine</em> 34 (1): 106–17. <a href="https://doi.org/10.1002/sim.6322">https://doi.org/10.1002/sim.6322</a>.
</div>
<div id="ref-Hajj2023" class="csl-entry">
Hajj, Ghadi S. Al, Johan Pensar, and Geir K. Sandve. 2023.
<span>“DagSim: Combining DAG-Based Model Structure with Unconstrained
Data Types and Relations for Flexible, Transparent, and Modularized Data
Simulation.”</span> <em>PLoS One</em> 18 (4). <a href="https://doi.org/10.1371/journal.pone.0284443">https://doi.org/10.1371/journal.pone.0284443</a>.
</div>
<div id="ref-Haller2014" class="csl-entry">
Haller, Bernhard, and Kurt Ulm. 2014. <span>“Flexible Simulation of
Competing Risks Data Following Prespecified Subdistribution
Hazards.”</span> <em>Journal of Statistical Computation and
Simulation</em> 84 (12): 2557–76. <a href="https://doi.org/10.1080/00949655.2013.793345">https://doi.org/10.1080/00949655.2013.793345</a>.
</div>
<div id="ref-Hendry2013" class="csl-entry">
Hendry, David J. 2013. <span>“Data Generation for the Cox Proportional
Hazards Model with Time-Dependent Covariates: A Method for Medical
Researchers.”</span> <em>Statistics in Medicine</em> 33 (3): 436–54. <a href="https://doi.org/10.1002/sim.5945">https://doi.org/10.1002/sim.5945</a>.
</div>
<div id="ref-Hernan2020" class="csl-entry">
Hernán, Miguel A., and James M. Robins. 2020. <em>Causal Inference: What
If</em>. CRC Press.
</div>
<div id="ref-Huang2020" class="csl-entry">
Huang, Yunda, Yuanyuan Zhang, Zong Zhang, and Peter B. Gilbert. 2020.
<span>“Generating Survival Times Using Cox Proportional Hazards Models
with Cyclic and Piecewise Time-Varying Covariates.”</span>
<em>Statistics in Biosciences</em> 12: 324–39. <a href="https://doi.org/10.1007/s12561-020-09266-3">https://doi.org/10.1007/s12561-020-09266-3</a>.
</div>
<div id="ref-Imbens2020" class="csl-entry">
Imbens, Guido W. 2020. <span>“Potential Outcome and Directed Acyclic
Graph Approaches to Causality: Relevance for Empirical Practice in
Economics.”</span> <em>Journal of Economic Literature</em> 58 (4):
1129–79. <a href="https://doi.org/10.1257/jel.20191597">https://doi.org/10.1257/jel.20191597</a>.
</div>
<div id="ref-Jorgensen2022" class="csl-entry">
Jorgensen, Terrence D., Sunthud Pornprasertmanit, Alexander M.
Schoemann, and Yves Rosseel. 2022. <em>semTools: <span>U</span>seful
Tools for Structural Equation Modeling</em>. <a href="https://CRAN.R-project.org/package=semTools">https://CRAN.R-project.org/package=semTools</a>.
</div>
<div id="ref-Kahn1962" class="csl-entry">
Kahn, A. B. 1962. <span>“Topological Sorting of Large Networks.”</span>
<em>Communications of the ACM</em> 5 (11): 558–62. <a href="https://doi.org/10.1145/368996.369025">https://doi.org/10.1145/368996.369025</a>.
</div>
<div id="ref-Kimko2002" class="csl-entry">
Kimko, Hui C., and Stephen B. Duffull, eds. 2002. <em>Simulation for
Designing Clinical Trials: A Pharmacokinetic-Pharmacodynamic Modeling
Perspective</em>. New York: Marcel Dekker Inc.
</div>
<div id="ref-Kline2023" class="csl-entry">
Kline, Rex B. 2023. <em>Principles and Practice of Structural Equation
Modeling</em>. 5. New York: The Guilford Press.
</div>
<div id="ref-Mersmann2023" class="csl-entry">
Mersmann, Olaf. 2023. <em>Microbenchmark: Accurate Timing
Functions</em>. <a href="https://CRAN.R-project.org/package=microbenchmark">https://CRAN.R-project.org/package=microbenchmark</a>.
</div>
<div id="ref-Morina2017" class="csl-entry">
Moriña, D., and A. Navarro. 2017. <span>“Competing Risks Simulation with
the Survsim r Package.”</span> <em>Communications in Statistics:
Simulation and Computation</em> 46 (7): 5712–22. <a href="https://doi.org/10.18637/jss.v059.i02">https://doi.org/10.18637/jss.v059.i02</a>.
</div>
<div id="ref-Morris2019" class="csl-entry">
Morris, Tim P., Ian R. White, and Michael J. Crowther. 2019.
<span>“Using Simulation Studies to Evaluate Statistical Methods.”</span>
<em>Statistics in Medicine</em> 38 (11): 2074–2102. <a href="https://doi.org/10.1002/sim.8086">https://doi.org/10.1002/sim.8086</a>.
</div>
<div id="ref-Nance2024" class="csl-entry">
Nance, Nerissa, Maya L. Petersen, Mark J. van der Laan, and Laura B.
Balzer. 2024. <span>“The Causal Roadmap and Simulations to Improve the
Rigor and Reproducibility of Real-Data Applications.”</span>
<em>Epidemiology</em> 35 (6): 791–800. <a href="https://doi.org/10.1097/EDE.0000000000001773">https://doi.org/10.1097/EDE.0000000000001773</a>.
</div>
<div id="ref-Ngwa2022" class="csl-entry">
Ngwa, Julius S., Howard J. Cabral, Debbie M. Cheng, David R. Gagnon,
Michael P. LaValley, and L. Adrienne Cupples. 2022. <span>“Generating
Survival Times with Time-Varying Covariates Using the Lambert w
Function.”</span> <em>Communications in Statistics: Simulation and
Computation</em> 51 (1): 135–53. <a href="https://doi.org/10.1080/03610918.2019.1648822">https://doi.org/10.1080/03610918.2019.1648822</a>.
</div>
<div id="ref-Pearl1995" class="csl-entry">
Pearl, Judea. 1995. <span>“Causal Diagrams for Empirical
Research.”</span> <em>Biometrika</em> 82 (4): 669–88. <a href="https://doi.org/10.2307/2337329">https://doi.org/10.2307/2337329</a>.
</div>
<div id="ref-Pearl2009" class="csl-entry">
———. 2009. <em>Causality: Models, Reasoning and Inference</em>. 2nd ed.
Cambridge: Cambridge University Press.
</div>
<div id="ref-Pedersen2022" class="csl-entry">
Pedersen, Thomas Lin. 2022. <em>Ggforce: Accelerating Ggplot2</em>. <a href="https://CRAN.R-project.org/package=ggforce">https://CRAN.R-project.org/package=ggforce</a>.
</div>
<div id="ref-Pitts2024" class="csl-entry">
Pitts, Amy J., and Charlotte R. Fowler. 2024. <span>“Comparison of
Open-Source Software for Producing Directed Acyclic Graphs.”</span>
<em>Journal of Causal Inference</em> 12 (1): 1–10. <a href="https://doi.org/10.1515/jci-2023-0031">https://doi.org/10.1515/jci-2023-0031</a>.
</div>
<div id="ref-Pornprasertmanit2021" class="csl-entry">
Pornprasertmanit, Sunthud, Patrick Miller, Alexander Schoemann, and
Terrence D. Jorgensen. 2021. <em>Simsem: SIMulated Structural Equation
Modeling</em>. <a href="https://CRAN.R-project.org/package=simsem">https://CRAN.R-project.org/package=simsem</a>.
</div>
<div id="ref-RCT2024" class="csl-entry">
R Core Team. 2024. <span>“R: A Language and Environment for Statistical
Computing.”</span> R Foundation for Statistical Computing, Vienna,
Austria. <a href="https://www.r-project.org/">https://www.r-project.org/</a>.
</div>
<div id="ref-Reisach2021" class="csl-entry">
Reisach, Alexander G., Christof Seiler, and Sebastian Weichwald. 2021.
<span>“Beware of the Simulated DAG! Causal Discovery Benchmarks May Be
Easy to Game.”</span> In <em>Advances in Neural Information Processing
Systems 34 (NeurIPS 2021)</em>, edited by Marc’Aurelio Ranzato, Alina
Beygelzimer, Yann N. Dauphin, Percy Liang, and Jennifer Wortman Vaughan.
arXiv:2102.13647v3.
</div>
<div id="ref-Rosseel2012" class="csl-entry">
Rosseel, Yves. 2012. <span>“Lavaan: An r Package for Structural Equation
Modeling.”</span> <em>Journal of Statistical Software</em> 48 (2): 1–36.
<a href="https://doi.org/10.18637/jss.v048.i02">https://doi.org/10.18637/jss.v048.i02</a>.
</div>
<div id="ref-Sigal2016" class="csl-entry">
Sigal, Matthew J., and R. Philip Chalmers. 2016. <span>“Play It Again:
Teaching Statistics with Monte Carlo Simulation.”</span> <em>Journal of
Statistics Education</em> 24 (3): 136–56. <a href="https://doi.org/10.1080/10691898.2016.1246953">https://doi.org/10.1080/10691898.2016.1246953</a>.
</div>
<div id="ref-Sofrygin2017" class="csl-entry">
Sofrygin, Oleg, Mark J. van der Laan, and Romain Neugebauer. 2017.
<span>“Simcausal r Package: Conducting Transparent and Reproducible
Simulation Studies of Causal Effect Estimation with Complex Longitudinal
Data.”</span> <em>Journal of Statistical Software</em> 81 (2): 1–47. <a href="https://doi.org/10.18637/jss.v081.i02">https://doi.org/10.18637/jss.v081.i02</a>.
</div>
<div id="ref-Spirtes2000" class="csl-entry">
Spirtes, Peter, Clark Glymour, and Richard Scheines. 2000.
<em>Causation, Prediction, and Search</em>. 2. Cambridge: MIT Press.
</div>
<div id="ref-Spooner2021" class="csl-entry">
Spooner, Fiona, Jesse F. Abrams, Karyn Morrissey, Gavin Shaddick,
Michael Batty, Richard Milton, Adam Dennett, et al. 2021. <span>“A
Dynamic Microsimulation Model for Epidemics.”</span> <em>Social Science
&amp; Medicine</em> 291 (114461). <a href="https://doi.org/10.1016/j.socscimed.2021.114461">https://doi.org/10.1016/j.socscimed.2021.114461</a>.
</div>
<div id="ref-Tang2020" class="csl-entry">
Tang, Jiangjun, George Leu, and Hussein A. Abbass. 2020. <em>Simulation
and Computational Red Teaming for Problem Solving</em>. Hoboke: John
Wiley &amp; Sons.
</div>
<div id="ref-Templ2017" class="csl-entry">
Templ, Matthias, Bernhard Meindl, Alexander Kowarik, and Olivier
Dupriez. 2017. <span>“Simulation of Synthetic Complex Data: The r
Package simPop.”</span> <em>Journal of Statistical Software</em> 79
(10): 1–38. <a href="https://doi.org/10.18637/jss.v079.i10">https://doi.org/10.18637/jss.v079.i10</a>.
</div>
<div id="ref-Textor2016" class="csl-entry">
Textor, Johannes, Benito van der Zander, Mark S. Gilthorpe, Maciej
Liśkiewicz, and George T. H. Ellison. 2016. <span>“Robust Causal
Inference Using Directed Acyclic Graphs: The r Package Daggity.”</span>
<em>International Journal of Epidemiology</em> 45 (6): 1887–94. <a href="https://doi.org/10.1093/ije/dyw341">https://doi.org/10.1093/ije/dyw341</a>.
</div>
<div id="ref-Therneau2024" class="csl-entry">
Therneau, Terry M. 2024. <em>A Package for Survival Analysis in r</em>.
<a href="https://CRAN.R-project.org/package=survival">https://CRAN.R-project.org/package=survival</a>.
</div>
<div id="ref-Tutz2016" class="csl-entry">
Tutz, Gerhard, and Matthias Schmid. 2016. <em>Modeling Discrete
Time-to-Event Data</em>. Cham: Springer International Publishing
Switzerland.
</div>
<div id="ref-Wang2022" class="csl-entry">
Wang, Wenjie, Haoda Fu, Sy Han, and Jun Yan. 2022. <em>Reda: Recurrent
Event Data Analysis</em>.
</div>
<div id="ref-Wickham2016" class="csl-entry">
Wickham, Hadley. 2016. <em>Ggplot2: Elegant Graphics for Data
Analysis</em>. Springer-Verlag New York. <a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</div>
<div id="ref-Wouk2019" class="csl-entry">
Wouk, Kathryn, Anna E. Bauer, and Nisha C. Gottfredson. 2019. <span>“How
to Implement Directed Acyclic Graphs to Reduce Bias in Addiction
Research.”</span> <em>Addictive Behaviors</em> 94: 109–16. <a href="https://doi.org/10.1016/j.addbeh.2018.09.032">https://doi.org/10.1016/j.addbeh.2018.09.032</a>.
</div>
<div id="ref-Zhang2018" class="csl-entry">
Zhang, Xiange. 2018. <span>“Application of Discrete Event Simulation in
Health Care: A Systematic Review.”</span> <em>BMC Health Services
Research</em> 18 (687). <a href="https://doi.org/10.1186/s12913-018-3456-4">https://doi.org/10.1186/s12913-018-3456-4</a>.
</div>
<div id="ref-Zhang2018a" class="csl-entry">
Zhang, Zhongzheng, Jaako Reinikainen, Kazeem Adedayo Adeleke, Marcel E.
Pieterse, and Catharina G. M. Groothuis-Oudshoorn. 2018.
<span>“Time-Varying Covariates and Coefficients in Cox Regression
Models.”</span> <em>Annals of Translational Medicine</em> 6 (7): 1–10.
<a href="https://doi.org/10.21037/atm.2018.02.12">https://doi.org/10.21037/atm.2018.02.12</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
